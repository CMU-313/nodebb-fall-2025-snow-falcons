                                     
                                     
┌───────────────────────────────────┐
│ 6 Reachable Supply Chain Findings │
└───────────────────────────────────┘
                                                                     
  [36m[22m[24m  src/middleware/index.js[0m with lockfile             
  [36m[22m[24mpackage-lock.json[0m                                   
   ❯❯❱ [1mconnect-multiparty - CVE-2022-29623[0m
          Severity: [1m[24mHIGH[0m                      
          Affected versions of connect-multiparty are   
          vulnerable to Unrestricted Upload of File with
          Dangerous Type.                               
                                                        
  [32m[22m[24m         ▶▶┆ Fixed for connect-multiparty at version:  
  [0m                                                                
           30┆ const multipartMiddleware = multipart();
            ⋮┆----------------------------------------
          303┆ multipartMiddleware(req, res, next);
                                                                     
  [36m[22m[24m  src/routes/admin.js[0m with lockfile                 
  [36m[22m[24mpackage-lock.json[0m                                   
   ❯❯❱ [1mconnect-multiparty - CVE-2022-29623[0m
          Severity: [1m[24mHIGH[0m                      
          Affected versions of connect-multiparty are   
          vulnerable to Unrestricted Upload of File with
          Dangerous Type.                               
                                                        
  [32m[22m[24m         ▶▶┆ Fixed for connect-multiparty at version:  
  [0m                                                                
           87┆ const multipartMiddleware = multipart();
                                                                     
  [36m[22m[24m  src/routes/api.js[0m with lockfile                   
  [36m[22m[24mpackage-lock.json[0m                                   
   ❯❯❱ [1mconnect-multiparty - CVE-2022-29623[0m
          Severity: [1m[24mHIGH[0m                      
          Affected versions of connect-multiparty are   
          vulnerable to Unrestricted Upload of File with
          Dangerous Type.                               
                                                        
  [32m[22m[24m         ▶▶┆ Fixed for connect-multiparty at version:  
  [0m                                                                
           27┆ const multipartMiddleware = multipart();
                                                                     
  [36m[22m[24m  src/routes/authentication.js[0m with lockfile        
  [36m[22m[24mpackage-lock.json[0m                                   
   ❯❯❱ [1mconnect-multiparty - CVE-2022-29623[0m
          Severity: [1m[24mHIGH[0m                      
          Affected versions of connect-multiparty are   
          vulnerable to Unrestricted Upload of File with
          Dangerous Type.                               
                                                        
  [32m[22m[24m         ▶▶┆ Fixed for connect-multiparty at version:  
  [0m                                                                
          158┆ const multipartMiddleware = multipart();
                                                                     
  [36m[22m[24m  src/routes/write/topics.js[0m with lockfile          
  [36m[22m[24mpackage-lock.json[0m                                   
   ❯❯❱ [1mconnect-multiparty - CVE-2022-29623[0m
          Severity: [1m[24mHIGH[0m                      
          Affected versions of connect-multiparty are   
          vulnerable to Unrestricted Upload of File with
          Dangerous Type.                               
                                                        
  [32m[22m[24m         ▶▶┆ Fixed for connect-multiparty at version:  
  [0m                                                                
           14┆ const multipartMiddleware = multipart();
                                        
                                        
┌──────────────────────────────────────┐
│ 4 Undetermined Supply Chain Findings │
└──────────────────────────────────────┘
                                    
  [36m[22m[24m  package-lock.json[0m
    ❯❱ [1mnodemailer - GHSA-mm7p-fcc7-pg87[0m
          Severity: [1m[24mMODERATE[0m                     
          Affected versions of nodemailer are vulnerable to
          Improper Input Validation / Interpretation       
          Conflict.                                        
                                                           
  [32m[22m[24m         ▶▶┆ Fixed for nodemailer at version: 7.0.7[0m
          11621┆ "node_modules/nodemailer": {
   
    ❯❱ [1mon-headers - CVE-2025-7339[0m
          Severity: [1m[24mLOW[0m                          
          Affected versions of on-headers are vulnerable to
          Improper Handling of Unexpected Data Type.       
                                                           
  [32m[22m[24m         ▶▶┆ Fixed for on-headers at version: 1.1.0[0m
          12147┆ "node_modules/on-headers": {
   
    ❯❱ [1mnodemailer - GHSA-mm7p-fcc7-pg87[0m
          Severity: [1m[24mMODERATE[0m                     
          Affected versions of nodemailer are vulnerable to
          Improper Input Validation / Interpretation       
          Conflict.                                        
                                                           
  [32m[22m[24m         ▶▶┆ Fixed for nodemailer at version: 7.0.7[0m
          15439┆ "node_modules/smtp-             
               server/node_modules/nodemailer": {
   
    ❯❱ [1mvalidator - CVE-2025-56200[0m
          Severity: [1m[24mMODERATE[0m                    
          Affected versions of validator are vulnerable to
          Improper Neutralization of Input During Web Page
          Generation ('Cross-site Scripting').            
                                                          
  [32m[22m[24m         ▶▶┆ Fixed for validator at version: [0m
          16919┆ "node_modules/validator": {
                                       
                                       
┌─────────────────────────────────────┐
│ 3 Unreachable Supply Chain Findings │
└─────────────────────────────────────┘
                                    
  [36m[22m[24m  package-lock.json[0m
   ❯❯❱ [1mform-data - CVE-2025-7783[0m
          Severity: [1m[24mCRITICAL[0m                     
          Affected versions of form-data are vulnerable to 
          Use of Insufficiently Random Values. form-data   
          generates its multipart boundary using           
          Math.random(), which is predictable if an        
          attacker can observe PRNG outputs. By determining
          the boundary value, an attacker can embed that   
          boundary in a user-controlled field and inject   
          arbitrary extra parameters into the multipart    
          payload, potentially manipulating or appending   
          fields in downstream HTTP requests.              
                                                           
  [32m[22m[24m         ▶▶┆ Fixed for form-data at versions: 2.5.4,   
  3.0.4, 4.0.4[0m                                                    
          7088┆ "node_modules/form-data": {
   
   ❯❯❱ [1mrequest - CVE-2023-28155[0m
          Severity: [1m[24mMODERATE[0m                     
          Affected versions of request are vulnerable to   
          Server-Side Request Forgery (Ssrf). The          
          vulnerability arises when SSRF filters (such as  
          `ssrf-req-filter`) implemented in the `request`  
          library inadvertently delete all configured      
          agents upon redirects involving protocol         
          switches, thus nullifying established event      
          listeners and anti-SSRF mechanisms, thereby      
          enabling attackers to circumvent SSRF protections
          and potentially acquire unauthorized access to   
          internal or restricted resources.                
                                                           
  [32m[22m[24m         ▶▶┆ Fixed for request at version: [0m
          13992┆ "node_modules/request": {
   
   ❯❯❱ [1mtough-cookie - CVE-2023-26136[0m
          Severity: [1m[24mMODERATE[0m                     
          Affected versions of tough-cookie are vulnerable 
          to Improperly Controlled Modification Of Object  
          Prototype Attributes ('Prototype Pollution') due 
          to improper handling of Cookies when using       
          `CookieJar` in `rejectPublicSuffixes=false` mode.
                                                           
  [32m[22m[24m         ▶▶┆ Fixed for tough-cookie at version:        
  4.1.3[0m                                                           
          14035┆                                       
               "node_modules/request/node_modules/tough
               -cookie": {                             
                                  
                                  
┌────────────────────────────────┐
│ 217 Non-blocking Code Findings │
└────────────────────────────────┘
                                           
  [36m[22m[24m  docker-compose-pgsql.yml[0m
    ❯❱ [1myaml.docker-compose.security.no-new-privileges.no-new-[0m
  [1m     privileges[0m                                            
          Service 'postgres' allows for privilege      
          escalation via setuid or setgid binaries. Add
          'no-new-privileges:true' in 'security_opt' to
          prevent this.                                
          Details: https://sg.run/0n8q                 
                                                       
           16┆ postgres:
   
    ❯❱ [1myaml.docker-compose.security.writable-filesystem-[0m
  [1m     service.writable-filesystem-service[0m              
          Service 'postgres' is running with a writable    
          root filesystem. This may allow malicious        
          applications to download and run additional      
          payloads, or modify container files. If an       
          application inside a container has to save       
          something temporarily consider using a tmpfs. Add
          'read_only: true' to this service to prevent     
          this.                                            
          Details: https://sg.run/e4JE                     
                                                           
           16┆ postgres:
   
    ❯❱ [1myaml.docker-compose.security.no-new-privileges.no-new-[0m
  [1m     privileges[0m                                            
          Service 'redis' allows for privilege escalation
          via setuid or setgid binaries. Add 'no-new-    
          privileges:true' in 'security_opt' to prevent  
          this.                                          
          Details: https://sg.run/0n8q                   
                                                         
           26┆ redis:
   
    ❯❱ [1myaml.docker-compose.security.writable-filesystem-[0m
  [1m     service.writable-filesystem-service[0m              
          Service 'redis' is running with a writable root  
          filesystem. This may allow malicious applications
          to download and run additional payloads, or      
          modify container files. If an application inside 
          a container has to save something temporarily    
          consider using a tmpfs. Add 'read_only: true' to 
          this service to prevent this.                    
          Details: https://sg.run/e4JE                     
                                                           
           26┆ redis:
                                           
  [36m[22m[24m  docker-compose-redis.yml[0m
    ❯❱ [1myaml.docker-compose.security.no-new-privileges.no-new-[0m
  [1m     privileges[0m                                            
          Service 'redis' allows for privilege escalation
          via setuid or setgid binaries. Add 'no-new-    
          privileges:true' in 'security_opt' to prevent  
          this.                                          
          Details: https://sg.run/0n8q                   
                                                         
           16┆ redis:
   
    ❯❱ [1myaml.docker-compose.security.writable-filesystem-[0m
  [1m     service.writable-filesystem-service[0m              
          Service 'redis' is running with a writable root  
          filesystem. This may allow malicious applications
          to download and run additional payloads, or      
          modify container files. If an application inside 
          a container has to save something temporarily    
          consider using a tmpfs. Add 'read_only: true' to 
          this service to prevent this.                    
          Details: https://sg.run/e4JE                     
                                                           
           16┆ redis:
                                 
  [36m[22m[24m  install/web.js[0m
     ❱ [1mjavascript.express.security.audit.express-check-csurf-[0m
  [1m     middleware-usage.express-check-csurf-middleware-usage[0m 
          A CSRF middleware was not detected in your      
          express application. Ensure you are either using
          one such as `csurf` or `csrf` (see rule         
          references) and/or you are properly doing CSRF  
          validation in your routes with a token or       
          cookies.                                        
          Details: https://sg.run/BxzR                    
                                                          
           22┆ const app = express();
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-default-name[0m     
          Don’t use the default session cookie name Using  
          the default session cookie name can open your app
          to attacks. The security issue posed is similar  
          to X-Powered-By: a potential attacker can use it 
          to fingerprint the server and target attacks     
          accordingly.                                     
          Details: https://sg.run/1Z5x                     
                                                           
           81┆ app.use(session({
           82┆    secret: utils.generateUUID(),
           83┆    resave: false,
           84┆    saveUninitialized: false,
           85┆ }));
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-no-domain[0m        
          Default session middleware settings: `domain` not
          set. It indicates the domain of the cookie; use  
          it to compare against the domain of the server in
          which the URL is being requested. If they match, 
          then check the path attribute next.              
          Details: https://sg.run/rd41                     
                                                           
           81┆ app.use(session({
           82┆    secret: utils.generateUUID(),
           83┆    resave: false,
           84┆    saveUninitialized: false,
           85┆ }));
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-no-expires[0m       
          Default session middleware settings: `expires`
          not set. Use it to set expiration date for    
          persistent cookies.                           
          Details: https://sg.run/N4eG                  
                                                        
           81┆ app.use(session({
           82┆    secret: utils.generateUUID(),
           83┆    resave: false,
           84┆    saveUninitialized: false,
           85┆ }));
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-no-httponly[0m      
          Default session middleware settings: `httpOnly` 
          not set. It ensures the cookie is sent only over
          HTTP(S), not client JavaScript, helping to      
          protect against cross-site scripting attacks.   
          Details: https://sg.run/ydBO                    
                                                          
           81┆ app.use(session({
           82┆    secret: utils.generateUUID(),
           83┆    resave: false,
           84┆    saveUninitialized: false,
           85┆ }));
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-no-path[0m          
          Default session middleware settings: `path` not 
          set. It indicates the path of the cookie; use it
          to compare against the request path. If this and
          domain match, then send the cookie in the       
          request.                                        
          Details: https://sg.run/b7pd                    
                                                          
           81┆ app.use(session({
           82┆    secret: utils.generateUUID(),
           83┆    resave: false,
           84┆    saveUninitialized: false,
           85┆ }));
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-no-secure[0m        
          Default session middleware settings: `secure` not
          set. It ensures the browser only sends the cookie
          over HTTPS.                                      
          Details: https://sg.run/9oKz                     
                                                           
           81┆ app.use(session({
           82┆    secret: utils.generateUUID(),
           83┆    resave: false,
           84┆    saveUninitialized: false,
           85┆ }));
   
   ❯❯❱ [1mjavascript.express.security.require-request.require-request[0m
          If an attacker controls the x in require(x) then 
          they can cause code to load that was not intended
          to run on the server.                            
          Details: https://sg.run/jRbl                     
                                                           
          129┆ db =                                 
               require(`../src/database/${dbName}`);
    
    
          Taint comes from:
    
          127┆ const keys = Object.keys(req.query);
    
    
          Taint flows through these intermediate variables:
    
          127┆ const keys = Object.keys(req.query);
    
          128┆ const dbName = keys[0].split(':')[0];
    
    
                This is how taint reaches the sink:
    
          129┆ db =                                 
               require(`../src/database/${dbName}`);
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ [1mjavascript.express.security.audit.remote-property-[0m
  [1m     injection.remote-property-injection[0m               
          Bracket object notation with user input is     
          present, this might allow an attacker to access
          all properties of the object and even it's     
          prototype. Use literal values for object       
          properties.                                    
          Details: https://sg.run/Z4gn                   
                                                         
          133┆ opts[key.replace(`${dbName}:`, '')] =
               req.query[key];                      
    
    
          Taint comes from:
    
          133┆ opts[key.replace(`${dbName}:`, '')] =
               req.query[key];                      
    
    
                This is how taint reaches the sink:
    
          133┆ opts[key.replace(`${dbName}:`, '')] =
               req.query[key];                      
    
                                                     
  [36m[22m[24m  public/src/admin/modules/search.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `term` function argument, 
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
           17┆ .replace(new RegExp('^(?:(?!' + escaped
               + ').)*$', 'gmi'), '')                 
    
    
          Taint comes from:
    
            6┆ function find(dict, term) {
    
    
          Taint flows through these intermediate variables:
    
            6┆ function find(dict, term) {
    
           13┆ const escaped =              
               utils.escapeRegexChars(term);
    
    
                This is how taint reaches the sink:
    
           17┆ .replace(new RegExp('^(?:(?!' + escaped
               + ').)*$', 'gmi'), '')                 
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `dict` function argument, 
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
           19┆ .replace(new RegExp('(^|\\n).*?' + title
               + '.*?(\\n|$)', 'g'), '')               
    
    
          Taint comes from:
    
            6┆ function find(dict, term) {
    
    
          Taint flows through these intermediate variables:
    
            6┆ function find(dict, term) {
    
            9┆ }).map(function (params) {
    
           12┆ let title = params.title;
    
    
                This is how taint reaches the sink:
    
           19┆ .replace(new RegExp('(^|\\n).*?' + title
               + '.*?(\\n|$)', 'g'), '')               
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `params` function         
          argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS)     
          within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use
          hardcoded regexes instead. If your regex is run  
          on user-controlled input, consider performing    
          input validation or use a regex                  
          checking/sanitization library such as            
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
           19┆ .replace(new RegExp('(^|\\n).*?' + title
               + '.*?(\\n|$)', 'g'), '')               
    
    
          Taint comes from:
    
            9┆ }).map(function (params) {
    
    
          Taint flows through these intermediate variables:
    
            9┆ }).map(function (params) {
    
           12┆ let title = params.title;
    
    
                This is how taint reaches the sink:
    
           19┆ .replace(new RegExp('(^|\\n).*?' + title
               + '.*?(\\n|$)', 'g'), '')               
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `term` function argument, 
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
           23┆ new RegExp('^[\\s\\S]*?(.{0,25})(' +
               escaped + ')(.{0,25})[\\s\\S]*?$',  
               'gmi'),                             
    
    
          Taint comes from:
    
            6┆ function find(dict, term) {
    
    
          Taint flows through these intermediate variables:
    
            6┆ function find(dict, term) {
    
           13┆ const escaped =              
               utils.escapeRegexChars(term);
    
    
                This is how taint reaches the sink:
    
           23┆ new RegExp('^[\\s\\S]*?(.{0,25})(' +
               escaped + ')(.{0,25})[\\s\\S]*?$',  
               'gmi'),                             
    
    
            ⋮┆----------------------------------------
           31┆ new RegExp('(^.*?)(' + escaped +
               ')(.*?$)', 'gi'),               
    
    
          Taint comes from:
    
            6┆ function find(dict, term) {
    
    
          Taint flows through these intermediate variables:
    
            6┆ function find(dict, term) {
    
           13┆ const escaped =              
               utils.escapeRegexChars(term);
    
    
                This is how taint reaches the sink:
    
           31┆ new RegExp('(^.*?)(' + escaped +
               ')(.*?$)', 'gi'),               
    
                                        
  [36m[22m[24m  public/src/ajaxify.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `val` function argument,  
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          296┆ return new RegExp(val);
    
    
          Taint comes from:
    
          295┆ const metaWhitelist = ['title',      
               'description', /og:.+/, /article:.+/,
               'robots'].map(function (val) {       
    
    
          Taint flows through these intermediate variables:
    
          295┆ const metaWhitelist = ['title',      
               'description', /og:.+/, /article:.+/,
               'robots'].map(function (val) {       
    
    
                This is how taint reaches the sink:
    
          296┆ return new RegExp(val);
    
                                               
  [36m[22m[24m  public/src/modules/search.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `searchQuery` function    
          argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS)     
          within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use
          hardcoded regexes instead. If your regex is run  
          on user-controlled input, consider performing    
          input validation or use a regex                  
          checking/sanitization library such as            
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          326┆ const regex = new RegExp('(' + regexStr
               + ')', 'gi');                          
    
    
          Taint comes from:
    
          317┆ Search.highlightMatches = function
               (searchQuery, els) {              
    
    
          Taint flows through these intermediate variables:
    
          317┆ Search.highlightMatches = function
               (searchQuery, els) {              
    
          322┆ const regexStr = searchQuery.split(' ')
    
    
                This is how taint reaches the sink:
    
          326┆ const regex = new RegExp('(' + regexStr
               + ')', 'gi');                          
    
                                                 
  [36m[22m[24m  public/src/modules/settings.js[0m
    ❯❱ [1mjavascript.lang.security.audit.prototype-[0m              
  [1m     pollution.prototype-pollution-loop.prototype-pollution-[0m
  [1m     loop[0m                                                   
          Possibility of prototype polluting function      
          detected. By adding or modifying attributes of an
          object prototype, it is possible to create       
          attributes that exist on every object, or replace
          critical attributes with malicious ones. This can
          be problematic if the software depends on        
          existence or non-existence of certain attributes,
          or uses pre-defined attributes of object         
          prototype (such as hasOwnProperty, toString or   
          valueOf). Possible mitigations might be: freezing
          the object prototype, using an object without    
          prototypes (via Object.create(null) ), blocking  
          modifications of attributes that resolve to      
          object prototype, using Map instead of object.   
          Details: https://sg.run/w1DB                     
                                                           
          214┆ value = value[part];
            ⋮┆----------------------------------------
          431┆ parentCfg = parentCfg[part];
                                                          
  [36m[22m[24m  public/src/modules/translator.common.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `i` function argument,    
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          267┆ out = out.replace(new RegExp('%' + (i +
               1), 'g'), escaped);                    
    
    
          Taint comes from:
    
          262┆ translatedArgs.forEach(function (arg, i)
               {                                       
    
    
          Taint flows through these intermediate variables:
    
          262┆ translatedArgs.forEach(function (arg, i)
               {                                       
    
    
                This is how taint reaches the sink:
    
          267┆ out = out.replace(new RegExp('%' + (i +
               1), 'g'), escaped);                    
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.prototype-[0m              
  [1m     pollution.prototype-pollution-loop.prototype-pollution-[0m
  [1m     loop[0m                                                   
          Possibility of prototype polluting function      
          detected. By adding or modifying attributes of an
          object prototype, it is possible to create       
          attributes that exist on every object, or replace
          critical attributes with malicious ones. This can
          be problematic if the software depends on        
          existence or non-existence of certain attributes,
          or uses pre-defined attributes of object         
          prototype (such as hasOwnProperty, toString or   
          valueOf). Possible mitigations might be: freezing
          the object prototype, using an object without    
          prototypes (via Object.create(null) ), blocking  
          modifications of attributes that resolve to      
          object prototype, using Map instead of object.   
          Details: https://sg.run/w1DB                     
                                                           
          302┆ x = x[keyParts[i]];
                                             
  [36m[22m[24m  public/src/utils.common.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `tags` function argument, 
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          301┆ return String(str).replace(new      
               RegExp('<(\\/)?(' + (pattern ||     
               '[^\\s>]+') +                       
               ')(\\s+[^<>]*?)?\\s*(\\/)?>', 'gi'),
               '');                                
    
    
          Taint comes from:
    
          299┆ stripHTMLTags: function (str, tags) {
    
    
          Taint flows through these intermediate variables:
    
          299┆ stripHTMLTags: function (str, tags) {
    
          300┆ const pattern = (tags ||
               ['']).join('|');        
    
          300┆ const pattern = (tags ||
               ['']).join('|');        
    
    
                This is how taint reaches the sink:
    
          301┆ return String(str).replace(new      
               RegExp('<(\\/)?(' + (pattern ||     
               '[^\\s>]+') +                       
               ')(\\s+[^<>]*?)?\\s*(\\/)?>', 'gi'),
               '');                                
    
                                           
  [36m[22m[24m  scripts/checkUserRole.js[0m
     ❱ [1mjavascript.lang.security.audit.unsafe-formatstring.unsafe-[0m
  [1m     formatstring[0m                                              
          Detected string concatenation with a non-literal 
          variable in a util.format / console.log function.
          If an attacker injects a format specifier in the 
          string, it will forge the log message. Try to use
          constant values for the format string.           
          Details: https://sg.run/7Y5R                     
                                                           
           12┆ console.log(`User ${uid} role:`, role);
    
    
          Taint comes from:
    
           12┆ console.log(`User ${uid} role:`, role);
    
    
                This is how taint reaches the sink:
    
           12┆ console.log(`User ${uid} role:`, role);
    
                                            
  [36m[22m[24m  scripts/testAssignRole.js[0m
     ❱ [1mjavascript.lang.security.audit.unsafe-formatstring.unsafe-[0m
  [1m     formatstring[0m                                              
          Detected string concatenation with a non-literal 
          variable in a util.format / console.log function.
          If an attacker injects a format specifier in the 
          string, it will forge the log message. Try to use
          constant values for the format string.           
          Details: https://sg.run/7Y5R                     
                                                           
           43┆ console.log(`👤 User ${adminUid} is
               admin:`, isAdmin);                 
    
    
          Taint comes from:
    
           43┆ console.log(`👤 User ${adminUid} is
               admin:`, isAdmin);                 
    
    
                This is how taint reaches the sink:
    
           43┆ console.log(`👤 User ${adminUid} is
               admin:`, isAdmin);                 
    
    
            ⋮┆----------------------------------------
           52┆ console.log(`👤 Target user ${targetUid}
               exists:`, userExists);                  
    
    
          Taint comes from:
    
           52┆ console.log(`👤 Target user ${targetUid}
               exists:`, userExists);                  
    
    
                This is how taint reaches the sink:
    
           52┆ console.log(`👤 Target user ${targetUid}
               exists:`, userExists);                  
    
                                           
  [36m[22m[24m  src/activitypub/mocks.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `actor` function argument,
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          202┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
          Taint comes from:
    
          167┆ const profiles = await                 
               Promise.all(actors.map(async (actor) =>
               {                                      
    
    
          Taint flows through these intermediate variables:
    
          167┆ const profiles = await                 
               Promise.all(actors.map(async (actor) =>
               {                                      
    
          176┆ name, summary, followers, inbox,
               endpoints, tag,                 
    
          201┆ .forEach((tag) => {
    
    
                This is how taint reaches the sink:
    
          202┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `actors` function         
          argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS)     
          within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use
          hardcoded regexes instead. If your regex is run  
          on user-controlled input, consider performing    
          input validation or use a regex                  
          checking/sanitization library such as            
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          202┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
          Taint comes from:
    
          165┆ Mocks.profile = async (actors) => {
    
    
          Taint flows through these intermediate variables:
    
          165┆ Mocks.profile = async (actors) => {
    
          167┆ const profiles = await                 
               Promise.all(actors.map(async (actor) =>
               {                                      
    
    
                This is how taint reaches the sink:
    
          202┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `tag` function argument,  
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          202┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
          Taint comes from:
    
          201┆ .forEach((tag) => {
    
    
          Taint flows through these intermediate variables:
    
          201┆ .forEach((tag) => {
    
    
                This is how taint reaches the sink:
    
          202┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `actor` function argument,
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          313┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
          Taint comes from:
    
          270┆ const categories = await               
               Promise.all(actors.map(async (actor) =>
               {                                      
    
    
          Taint flows through these intermediate variables:
    
          270┆ const categories = await               
               Promise.all(actors.map(async (actor) =>
               {                                      
    
          279┆ name, summary, followers, inbox,
               endpoints, tag,                 
    
          312┆ .forEach((tag) => {
    
    
                This is how taint reaches the sink:
    
          313┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `actors` function         
          argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS)     
          within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use
          hardcoded regexes instead. If your regex is run  
          on user-controlled input, consider performing    
          input validation or use a regex                  
          checking/sanitization library such as            
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          313┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
          Taint comes from:
    
          269┆ Mocks.category = async (actors) => {
    
    
          Taint flows through these intermediate variables:
    
          269┆ Mocks.category = async (actors) => {
    
          270┆ const categories = await               
               Promise.all(actors.map(async (actor) =>
               {                                      
    
    
                This is how taint reaches the sink:
    
          313┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `tag` function argument,  
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          313┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
          Taint comes from:
    
          312┆ .forEach((tag) => {
    
    
          Taint flows through these intermediate variables:
    
          312┆ .forEach((tag) => {
    
    
                This is how taint reaches the sink:
    
          313┆ summary = summary.replace(new           
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
                                           
  [36m[22m[24m  src/activitypub/notes.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `input` function argument,
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          155┆ title = title.replace(new  
               RegExp(tag.name, 'g'), '');
    
    
          Taint comes from:
    
           48┆ Notes.assert = async (uid, input,    
               options = { skipChecks: false }) => {
    
    
          Taint flows through these intermediate variables:
    
           48┆ Notes.assert = async (uid, input,    
               options = { skipChecks: false }) => {
    
           71┆ chain = Array.from(await          
               activitypub.contexts.getItems(uid,
               context.context, { input }));     
    
           71┆ chain = Array.from(await          
               activitypub.contexts.getItems(uid,
               context.context, { input }));     
    
           95┆ const mainPost = chain[0];
    
           96┆ let { pid: mainPid, tid, uid: authorId,
               timestamp, title, content,             
               sourceContent, _activitypub } =        
               mainPost;                              
    
          154┆ .forEach((tag) => {
    
    
                This is how taint reaches the sink:
    
          155┆ title = title.replace(new  
               RegExp(tag.name, 'g'), '');
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `tag` function argument,  
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          155┆ title = title.replace(new  
               RegExp(tag.name, 'g'), '');
    
    
          Taint comes from:
    
          154┆ .forEach((tag) => {
    
    
          Taint flows through these intermediate variables:
    
          154┆ .forEach((tag) => {
    
    
                This is how taint reaches the sink:
    
          155┆ title = title.replace(new  
               RegExp(tag.name, 'g'), '');
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `uid` function argument,  
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          155┆ title = title.replace(new  
               RegExp(tag.name, 'g'), '');
    
    
          Taint comes from:
    
           48┆ Notes.assert = async (uid, input,    
               options = { skipChecks: false }) => {
    
    
          Taint flows through these intermediate variables:
    
           48┆ Notes.assert = async (uid, input,    
               options = { skipChecks: false }) => {
    
           71┆ chain = Array.from(await          
               activitypub.contexts.getItems(uid,
               context.context, { input }));     
    
           71┆ chain = Array.from(await          
               activitypub.contexts.getItems(uid,
               context.context, { input }));     
    
           95┆ const mainPost = chain[0];
    
           96┆ let { pid: mainPid, tid, uid: authorId,
               timestamp, title, content,             
               sourceContent, _activitypub } =        
               mainPost;                              
    
          154┆ .forEach((tag) => {
    
    
                This is how taint reaches the sink:
    
          155┆ title = title.replace(new  
               RegExp(tag.name, 'g'), '');
    
                                      
  [36m[22m[24m  src/admin/search.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           62┆ const template = await fs.promises.readF
               ile(path.resolve(nconf.get('views_dir'),
               `${namespace}.tpl`), 'utf8');           
    
    
          Taint comes from:
    
           88┆ const namespaces = await
               getAdminNamespaces();   
    
          then call to:
    
           33┆ return filterDirectories(directories);
    
          Taint flows through these intermediate variables:
    
           12┆ function filterDirectories(directories)
               {                                      
    
          then reaches:
    
           12┆ function filterDirectories(directories)
               {                                      
    
    
          Taint flows through these intermediate variables:
    
           88┆ const namespaces = await
               getAdminNamespaces();   
    
           88┆ const namespaces = await
               getAdminNamespaces();   
    
           89┆ return await                    
               Promise.all(namespaces.map(ns =>
               buildNamespace(language, ns))); 
    
    
                This is how taint reaches the sink:
    
           89┆ return await                    
               Promise.all(namespaces.map(ns =>
               buildNamespace(language, ns))); 
    
          Taint flows through these intermediate variables:
    
           92┆ async function buildNamespace(language,
               namespace) {                           
    
          then call to:
    
           97┆ return await fallback(namespace);
    
          Taint flows through these intermediate variables:
    
           77┆ async function fallback(namespace) {
    
          then call to:
    
           82┆ const params = await    
               initFallback(namespace);
    
          Taint flows through these intermediate variables:
    
           61┆ async function initFallback(namespace) {
    
          then reaches:
    
           62┆ const template = await fs.promises.readF
               ile(path.resolve(nconf.get('views_dir'),
               `${namespace}.tpl`), 'utf8');           
    
                                   
  [36m[22m[24m  src/api/users.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          664┆ const stat = await               
               fs.stat(path.join(__dirname,     
               '../../build/export', filename));
    
    
          Taint comes from:
    
          660┆ const prepareExport = async ({ uid, type
               }) => {                                 
    
    
          Taint flows through these intermediate variables:
    
          660┆ const prepareExport = async ({ uid, type
               }) => {                                 
    
          662┆ const filename =              
               `${uid}_${type}.${extension}`;
    
          662┆ const filename =              
               `${uid}_${type}.${extension}`;
    
    
                This is how taint reaches the sink:
    
          664┆ const stat = await               
               fs.stat(path.join(__dirname,     
               '../../build/export', filename));
    
                                         
  [36m[22m[24m  src/categories/icon.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           21┆ const paths =                           
               Icons._constants.extensions.map(extensio
               n =>                                    
               path.resolve(nconf.get('upload_path'),  
               'category',                             
               `category-${cid}-icon.${extension}`));  
    
    
          Taint comes from:
    
           19┆ Icons.get = async (cid) => {
    
    
          Taint flows through these intermediate variables:
    
           19┆ Icons.get = async (cid) => {
    
    
                This is how taint reaches the sink:
    
           21┆ const paths =                           
               Icons._constants.extensions.map(extensio
               n =>                                    
               path.resolve(nconf.get('upload_path'),  
               'category',                             
               `category-${cid}-icon.${extension}`));  
    
    
            ⋮┆----------------------------------------
           37┆ const paths =                           
               Icons._constants.extensions.map(extensio
               n =>                                    
               path.resolve(nconf.get('upload_path'),  
               'category',                             
               `category-${cid}-icon.${extension}`));  
    
    
          Taint comes from:
    
           35┆ Icons.flush = async (cid) => {
    
    
          Taint flows through these intermediate variables:
    
           35┆ Icons.flush = async (cid) => {
    
    
                This is how taint reaches the sink:
    
           37┆ const paths =                           
               Icons._constants.extensions.map(extensio
               n =>                                    
               path.resolve(nconf.get('upload_path'),  
               'category',                             
               `category-${cid}-icon.${extension}`));  
    
    
            ⋮┆----------------------------------------
           96┆ await fs.writeFile(path.resolve(nconf.ge
               t('upload_path'), 'category',           
               `category-${cid}-icon.svg`), svg);      
    
    
          Taint comes from:
    
           42┆ Icons.regenerate = async (cid) => {
    
    
          Taint flows through these intermediate variables:
    
           42┆ Icons.regenerate = async (cid) => {
    
    
                This is how taint reaches the sink:
    
           96┆ await fs.writeFile(path.resolve(nconf.ge
               t('upload_path'), 'category',           
               `category-${cid}-icon.svg`), svg);      
    
    
            ⋮┆----------------------------------------
          103┆ await fs.writeFile(path.resolve(nconf.ge
               t('upload_path'), 'category',           
               `category-${cid}-icon.png`), pngBuffer);
    
    
          Taint comes from:
    
           42┆ Icons.regenerate = async (cid) => {
    
    
          Taint flows through these intermediate variables:
    
           42┆ Icons.regenerate = async (cid) => {
    
    
                This is how taint reaches the sink:
    
          103┆ await fs.writeFile(path.resolve(nconf.ge
               t('upload_path'), 'category',           
               `category-${cid}-icon.png`), pngBuffer);
    
                                   
  [36m[22m[24m  src/cli/index.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           29┆ const { version } = JSON.parse(fs.readFi
               leSync(path.join(paths.nodeModules,     
               packageName, 'package.json'), 'utf8')); 
    
    
          Taint comes from:
    
           28┆ const checkVersion = function
               (packageName) {              
    
    
          Taint flows through these intermediate variables:
    
           28┆ const checkVersion = function
               (packageName) {              
    
    
                This is how taint reaches the sink:
    
           29┆ const { version } = JSON.parse(fs.readFi
               leSync(path.join(paths.nodeModules,     
               packageName, 'package.json'), 'utf8')); 
    
                                             
  [36m[22m[24m  src/cli/package-install.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          159┆ const isLink =                          
               fs.lstatSync(path.join(paths.nodeModules
               , pkgName)).isSymbolicLink();           
    
    
          Taint comes from:
    
          157┆ .filter((pkgName) => {
    
    
          Taint flows through these intermediate variables:
    
          157┆ .filter((pkgName) => {
    
    
                This is how taint reaches the sink:
    
          159┆ const isLink =                          
               fs.lstatSync(path.join(paths.nodeModules
               , pkgName)).isSymbolicLink();           
    
    
            ⋮┆----------------------------------------
          165┆ const pkgConfig = JSON.parse(fs.readFile
               Sync(path.join(paths.nodeModules,       
               pkgName, 'package.json'), 'utf8'));     
    
    
          Taint comes from:
    
          164┆ .reduce((map, pkgName) => {
    
    
          Taint flows through these intermediate variables:
    
          164┆ .reduce((map, pkgName) => {
    
    
                This is how taint reaches the sink:
    
          165┆ const pkgConfig = JSON.parse(fs.readFile
               Sync(path.join(paths.nodeModules,       
               pkgName, 'package.json'), 'utf8'));     
    
                                   
  [36m[22m[24m  src/cli/reset.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           99┆ await fs.promises.access(path.join(paths
               .nodeModules, themeId, 'package.json'));
    
    
          Taint comes from:
    
           17┆ exports.reset = async function (options)
               {                                       
    
    
          Taint flows through these intermediate variables:
    
           17┆ exports.reset = async function (options)
               {                                       
    
           20┆ let themeId = options.theme;
    
    
                This is how taint reaches the sink:
    
           30┆ await resetTheme(themeId);
    
          Taint flows through these intermediate variables:
    
           97┆ async function resetTheme(themeId) {
    
          then reaches:
    
           99┆ await fs.promises.access(path.join(paths
               .nodeModules, themeId, 'package.json'));
    
                                             
  [36m[22m[24m  src/cli/upgrade-plugins.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           28┆ path.join(paths.nodeModules, module,  
               'package.json'), { encoding: 'utf-8' }
    
    
          Taint comes from:
    
           25┆ await batch.processArray(modules, async
               (moduleNames) => {                     
    
    
          Taint flows through these intermediate variables:
    
           25┆ await batch.processArray(modules, async
               (moduleNames) => {                     
    
           26┆ await Promise.all(moduleNames.map(async
               (module) => {                          
    
    
                This is how taint reaches the sink:
    
           28┆ path.join(paths.nodeModules, module,  
               'package.json'), { encoding: 'utf-8' }
    
    
            ⋮┆----------------------------------------
           60┆                                         
               fs.accessSync(path.join(paths.nodeModule
               s, pkgName, '.git'));                   
    
    
          Taint comes from:
    
           53┆ const checklist = deps.filter((pkgName)
               => {                                   
    
    
          Taint flows through these intermediate variables:
    
           53┆ const checklist = deps.filter((pkgName)
               => {                                   
    
    
                This is how taint reaches the sink:
    
           60┆                                         
               fs.accessSync(path.join(paths.nodeModule
               s, pkgName, '.git'));                   
    
                                                        
  [36m[22m[24m  src/controllers/activitypub/actors.js[0m
    ❯❱ [1mjavascript.express.web.tainted-redirect-express.tainted-[0m
  [1m     redirect-express[0m                                        
          The application builds a URL using user-         
          controlled input which can lead to an open       
          redirect vulnerability. An attacker can          
          manipulate the URL and redirect users to an      
          arbitrary domain. Open redirect vulnerabilities  
          can lead to issues such as Cross-site scripting  
          (XSS) or redirecting to a malicious domain for   
          activities such as phishing to capture users'    
          credentials. To prevent this vulnerability       
          perform strict input validation of the domain    
          against an allowlist of approved domains. Notify 
          a user in your application that they are leaving 
          the website. Display a domain where they are     
          redirected to the user. A user can then either   
          accept or deny the redirect to an untrusted site.
          Details: https://sg.run/7KEAw                    
                                                           
           68┆ return res.set('Location',      
               req.params.pid).sendStatus(308);
    
    
          Taint comes from:
    
           68┆ return res.set('Location',      
               req.params.pid).sendStatus(308);
    
    
                This is how taint reaches the sink:
    
           68┆ return res.set('Location',      
               req.params.pid).sendStatus(308);
    
    
            ⋮┆----------------------------------------
          213┆ return res.set('Location',      
               req.params.mid).sendStatus(308);
    
    
          Taint comes from:
    
          213┆ return res.set('Location',      
               req.params.mid).sendStatus(308);
    
    
                This is how taint reaches the sink:
    
          213┆ return res.set('Location',      
               req.params.mid).sendStatus(308);
    
                                                  
  [36m[22m[24m  src/controllers/admin/groups.js[0m
    ❯❱ [1mjavascript.express.web.tainted-redirect-express.tainted-[0m
  [1m     redirect-express[0m                                        
          The application builds a URL using user-         
          controlled input which can lead to an open       
          redirect vulnerability. An attacker can          
          manipulate the URL and redirect users to an      
          arbitrary domain. Open redirect vulnerabilities  
          can lead to issues such as Cross-site scripting  
          (XSS) or redirecting to a malicious domain for   
          activities such as phishing to capture users'    
          credentials. To prevent this vulnerability       
          perform strict input validation of the domain    
          against an allowlist of approved domains. Notify 
          a user in your application that they are leaving 
          the website. Display a domain where they are     
          redirected to the user. A user can then either   
          accept or deny the redirect to an untrusted site.
          Details: https://sg.run/7KEAw                    
                                                           
           39┆ return res.redirect(`${nconf.get('relati
               ve_path')}/admin/manage/groups/${lowerca
               seSlug}`);                              
    
    
          Taint comes from:
    
           34┆ const lowercaseSlug =         
               req.params.slug.toLowerCase();
    
    
          Taint flows through these intermediate variables:
    
           34┆ const lowercaseSlug =         
               req.params.slug.toLowerCase();
    
    
                This is how taint reaches the sink:
    
           39┆ return res.redirect(`${nconf.get('relati
               ve_path')}/admin/manage/groups/${lowerca
               seSlug}`);                              
    
                                                
  [36m[22m[24m  src/controllers/admin/info.js[0m
   ❯❯❱ [1mjavascript.lang.security.detect-child-process.detect-child-[0m
  [1m     process[0m                                                    
          Detected calls to child_process from a function 
          argument `cmd`. This could lead to a command    
          injection if the input is user controllable. Try
          to avoid calls to child_process, and if it is   
          needed ensure user input is correctly sanitized 
          or sandboxed.                                   
          Details: https://sg.run/l2lo                    
                                                          
          132┆ exec(cmd, (err, stdout) => {
    
    
          Taint comes from:
    
          131┆ function get(cmd, callback) {
    
    
          Taint flows through these intermediate variables:
    
          131┆ function get(cmd, callback) {
    
    
                This is how taint reaches the sink:
    
          132┆ exec(cmd, (err, stdout) => {
    
                                                  
  [36m[22m[24m  src/controllers/admin/themes.js[0m
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
          Taint comes from:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
                This is how taint reaches the sink:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
          Taint comes from:
    
           13┆ themesController.get = async function
               (req, res, next) {                   
    
    
          Taint flows through these intermediate variables:
    
           13┆ themesController.get = async function
               (req, res, next) {                   
    
    
                This is how taint reaches the sink:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
           15┆ const themeConfigPath =           
               path.join(themeDir, 'theme.json');
    
    
          Taint comes from:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
          Taint flows through these intermediate variables:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
                This is how taint reaches the sink:
    
           15┆ const themeConfigPath =           
               path.join(themeDir, 'theme.json');
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           15┆ const themeConfigPath =           
               path.join(themeDir, 'theme.json');
    
    
          Taint comes from:
    
           13┆ themesController.get = async function
               (req, res, next) {                   
    
    
          Taint flows through these intermediate variables:
    
           13┆ themesController.get = async function
               (req, res, next) {                   
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
                This is how taint reaches the sink:
    
           15┆ const themeConfigPath =           
               path.join(themeDir, 'theme.json');
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.express-fs-filename.express-fs-filename[0m
          The application builds a file path from          
          potentially untrusted data, which can lead to a  
          path traversal vulnerability. An attacker can    
          manipulate the file path which the application   
          uses to access files. If the application does not
          validate user input and sanitize file paths,     
          sensitive files such as configuration or user    
          data can be accessed, potentially creating or    
          overwriting files. To prevent this vulnerability,
          validate and sanitize any input that is used to  
          create references to file paths. Also, enforce   
          strict file access controls. For example, choose 
          privileges allowing public-facing applications to
          access only the required files.                  
          Details: https://sg.run/0B9W                     
                                                           
           19┆ themeConfig = await                  
               fs.promises.readFile(themeConfigPath,
               'utf8');                             
    
    
          Taint comes from:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
          Taint flows through these intermediate variables:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
           15┆ const themeConfigPath =           
               path.join(themeDir, 'theme.json');
    
    
                This is how taint reaches the sink:
    
           19┆ themeConfig = await                  
               fs.promises.readFile(themeConfigPath,
               'utf8');                             
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
           29┆ path.join(themeDir,      
               themeConfig.screenshot) :
    
    
          Taint comes from:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
          Taint flows through these intermediate variables:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
                This is how taint reaches the sink:
    
           29┆ path.join(themeDir,      
               themeConfig.screenshot) :
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           29┆ path.join(themeDir,      
               themeConfig.screenshot) :
    
    
          Taint comes from:
    
           13┆ themesController.get = async function
               (req, res, next) {                   
    
    
          Taint flows through these intermediate variables:
    
           13┆ themesController.get = async function
               (req, res, next) {                   
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
                This is how taint reaches the sink:
    
           29┆ path.join(themeDir,      
               themeConfig.screenshot) :
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
           29┆ path.join(themeDir,      
               themeConfig.screenshot) :
    
    
          Taint comes from:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
          Taint flows through these intermediate variables:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
           15┆ const themeConfigPath =           
               path.join(themeDir, 'theme.json');
    
           19┆ themeConfig = await                  
               fs.promises.readFile(themeConfigPath,
               'utf8');                             
    
           19┆ themeConfig = await                  
               fs.promises.readFile(themeConfigPath,
               'utf8');                             
    
    
                This is how taint reaches the sink:
    
           29┆ path.join(themeDir,      
               themeConfig.screenshot) :
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           29┆ path.join(themeDir,      
               themeConfig.screenshot) :
    
    
          Taint comes from:
    
           13┆ themesController.get = async function
               (req, res, next) {                   
    
    
          Taint flows through these intermediate variables:
    
           13┆ themesController.get = async function
               (req, res, next) {                   
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
           15┆ const themeConfigPath =           
               path.join(themeDir, 'theme.json');
    
           19┆ themeConfig = await                  
               fs.promises.readFile(themeConfigPath,
               'utf8');                             
    
           19┆ themeConfig = await                  
               fs.promises.readFile(themeConfigPath,
               'utf8');                             
    
    
                This is how taint reaches the sink:
    
           29┆ path.join(themeDir,      
               themeConfig.screenshot) :
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.audit.express-res-[0m
  [1m     sendfile.express-res-sendfile[0m                 
          The application processes user-input, this is   
          passed to res.sendFile which can allow an       
          attacker to arbitrarily read files on the system
          through path traversal. It is recommended to    
          perform input validation in addition to         
          canonicalizing the path. This allows you to     
          validate the path against the intended directory
          it should be accessing.                         
          Details: https://sg.run/7DJk                    
                                                          
           36┆ res.sendFile(exists ? screenshotPath :
               defaultScreenshotPath);               
    
    
          Taint comes from:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
    
          Taint flows through these intermediate variables:
    
           14┆ const themeDir =            
               path.join(paths.nodeModules,
               req.params.theme);          
    
           28┆ const screenshotPath =  
               themeConfig.screenshot ?
    
    
                This is how taint reaches the sink:
    
           36┆ res.sendFile(exists ? screenshotPath :
               defaultScreenshotPath);               
    
                                                   
  [36m[22m[24m  src/controllers/admin/uploads.js[0m
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
          Taint comes from:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
                This is how taint reaches the sink:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
          Taint comes from:
    
           19┆ uploadsController.get = async function
               (req, res, next) {                    
    
    
          Taint flows through these intermediate variables:
    
           19┆ uploadsController.get = async function
               (req, res, next) {                    
    
    
                This is how taint reaches the sink:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
           77┆ const nextPath =                   
               path.join(nconf.get('upload_path'),
               dir);                              
    
    
          Taint comes from:
    
           28┆ await checkSymLinks(req.query.dir);
    
    
                This is how taint reaches the sink:
    
           28┆ await checkSymLinks(req.query.dir);
    
          Taint flows through these intermediate variables:
    
           74┆ async function checkSymLinks(folder) {
    
           75┆ let dir = path.normalize(folder || '');
    
          then reaches:
    
           77┆ const nextPath =                   
               path.join(nconf.get('upload_path'),
               dir);                              
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           77┆ const nextPath =                   
               path.join(nconf.get('upload_path'),
               dir);                              
    
    
          Taint comes from:
    
           19┆ uploadsController.get = async function
               (req, res, next) {                    
    
    
          Taint flows through these intermediate variables:
    
           19┆ uploadsController.get = async function
               (req, res, next) {                    
    
    
                This is how taint reaches the sink:
    
           28┆ await checkSymLinks(req.query.dir);
    
          Taint flows through these intermediate variables:
    
           74┆ async function checkSymLinks(folder) {
    
           75┆ let dir = path.normalize(folder || '');
    
          then reaches:
    
           77┆ const nextPath =                   
               path.join(nconf.get('upload_path'),
               dir);                              
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.express-fs-filename.express-fs-filename[0m
          The application builds a file path from          
          potentially untrusted data, which can lead to a  
          path traversal vulnerability. An attacker can    
          manipulate the file path which the application   
          uses to access files. If the application does not
          validate user input and sanitize file paths,     
          sensitive files such as configuration or user    
          data can be accessed, potentially creating or    
          overwriting files. To prevent this vulnerability,
          validate and sanitize any input that is used to  
          create references to file paths. Also, enforce   
          strict file access controls. For example, choose 
          privileges allowing public-facing applications to
          access only the required files.                  
          Details: https://sg.run/0B9W                     
                                                           
           79┆ const stat = await          
               fs.promises.lstat(nextPath);
    
    
          Taint comes from:
    
           28┆ await checkSymLinks(req.query.dir);
    
    
                This is how taint reaches the sink:
    
           28┆ await checkSymLinks(req.query.dir);
    
          Taint flows through these intermediate variables:
    
           74┆ async function checkSymLinks(folder) {
    
           75┆ let dir = path.normalize(folder || '');
    
           77┆ const nextPath =                   
               path.join(nconf.get('upload_path'),
               dir);                              
    
          then reaches:
    
           79┆ const stat = await          
               fs.promises.lstat(nextPath);
    
    
            ⋮┆----------------------------------------
           92┆ const dirents = await        
               fs.promises.readdir(folder, {
               withFileTypes: true });      
    
    
          Taint comes from:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
          Taint flows through these intermediate variables:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
                This is how taint reaches the sink:
    
           29┆ files = await                   
               getFilesInFolder(currentFolder);
    
          Taint flows through these intermediate variables:
    
           91┆ async function getFilesInFolder(folder)
               {                                      
    
          then reaches:
    
           92┆ const dirents = await        
               fs.promises.readdir(folder, {
               withFileTypes: true });      
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ [1mjavascript.express.file.fs-express.fs-express[0m
          The application builds a file path from          
          potentially untrusted data, which can lead to a  
          path traversal vulnerability. An attacker can    
          manipulate the path which the application uses to
          access files. If the application does not        
          validate user input and sanitize file paths,     
          sensitive files such as configuration or user    
          data can be accessed, potentially creating or    
          overwriting files. To prevent this vulnerability,
          validate and sanitize any input that is used to  
          create references to file paths. Also, enforce   
          strict file access controls. For example, choose 
          privileges allowing public-facing applications to
          access only the required files.                  
          Details: https://sg.run/GdqX1                    
                                                           
           92┆ const dirents = await        
               fs.promises.readdir(folder, {
               withFileTypes: true });      
    
    
          Taint comes from:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
          Taint flows through these intermediate variables:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
                This is how taint reaches the sink:
    
           29┆ files = await                   
               getFilesInFolder(currentFolder);
    
          Taint flows through these intermediate variables:
    
           91┆ async function getFilesInFolder(folder)
               {                                      
    
          then reaches:
    
           92┆ const dirents = await        
               fs.promises.readdir(folder, {
               withFileTypes: true });      
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          107┆ const dir = path.join(currentPath,
               part);                            
    
    
          Taint comes from:
    
          106┆ parts.forEach((part, i) => {
    
    
          Taint flows through these intermediate variables:
    
          106┆ parts.forEach((part, i) => {
    
    
                This is how taint reaches the sink:
    
          107┆ const dir = path.join(currentPath,
               part);                            
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
          128┆ const pathToFile = path.join(currentDir,
               file);                                  
    
    
          Taint comes from:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
          Taint flows through these intermediate variables:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
                This is how taint reaches the sink:
    
           40┆ files = await filesToData(currentFolder,
               files);                                 
    
          Taint flows through these intermediate variables:
    
          123┆ async function filesToData(currentDir,
               files) {                              
    
          then call to:
    
          124┆ return await Promise.all(files.map(file
               => getFileData(currentDir, file)));    
    
          Taint flows through these intermediate variables:
    
          127┆ async function getFileData(currentDir,
               file) {                               
    
          then reaches:
    
          128┆ const pathToFile = path.join(currentDir,
               file);                                  
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          128┆ const pathToFile = path.join(currentDir,
               file);                                  
    
    
          Taint comes from:
    
           19┆ uploadsController.get = async function
               (req, res, next) {                    
    
    
          Taint flows through these intermediate variables:
    
           19┆ uploadsController.get = async function
               (req, res, next) {                    
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
                This is how taint reaches the sink:
    
           40┆ files = await filesToData(currentFolder,
               files);                                 
    
          Taint flows through these intermediate variables:
    
          123┆ async function filesToData(currentDir,
               files) {                              
    
          then call to:
    
          124┆ return await Promise.all(files.map(file
               => getFileData(currentDir, file)));    
    
          Taint flows through these intermediate variables:
    
          127┆ async function getFileData(currentDir,
               file) {                               
    
          then reaches:
    
          128┆ const pathToFile = path.join(currentDir,
               file);                                  
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
          128┆ const pathToFile = path.join(currentDir,
               file);                                  
    
    
          Taint comes from:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
          Taint flows through these intermediate variables:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
           29┆ files = await                   
               getFilesInFolder(currentFolder);
    
           91┆ async function getFilesInFolder(folder)
               {                                      
    
           92┆ const dirents = await        
               fs.promises.readdir(folder, {
               withFileTypes: true });      
    
           92┆ const dirents = await        
               fs.promises.readdir(folder, {
               withFileTypes: true });      
    
           94┆ for await (const dirent of dirents) {
    
           94┆ for await (const dirent of dirents) {
    
           96┆ files.push(dirent.name);
    
           29┆ files = await                   
               getFilesInFolder(currentFolder);
    
           29┆ files = await                   
               getFilesInFolder(currentFolder);
    
    
                This is how taint reaches the sink:
    
           40┆ files = await filesToData(currentFolder,
               files);                                 
    
          Taint flows through these intermediate variables:
    
          123┆ async function filesToData(currentDir,
               files) {                              
    
          124┆ return await Promise.all(files.map(file
               => getFileData(currentDir, file)));    
    
          then call to:
    
          124┆ return await Promise.all(files.map(file
               => getFileData(currentDir, file)));    
    
          Taint flows through these intermediate variables:
    
          127┆ async function getFileData(currentDir,
               file) {                               
    
          then reaches:
    
          128┆ const pathToFile = path.join(currentDir,
               file);                                  
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          128┆ const pathToFile = path.join(currentDir,
               file);                                  
    
    
          Taint comes from:
    
           19┆ uploadsController.get = async function
               (req, res, next) {                    
    
    
          Taint flows through these intermediate variables:
    
           19┆ uploadsController.get = async function
               (req, res, next) {                    
    
           25┆ const page = parseInt(req.query.page,
               10) || 1;                            
    
           36┆ const start = Math.max(0, (page - 1) *
               itemsPerPage);                        
    
           38┆ files = files.slice(start, stop);
    
    
                This is how taint reaches the sink:
    
           40┆ files = await filesToData(currentFolder,
               files);                                 
    
          Taint flows through these intermediate variables:
    
          123┆ async function filesToData(currentDir,
               files) {                              
    
          124┆ return await Promise.all(files.map(file
               => getFileData(currentDir, file)));    
    
          then call to:
    
          124┆ return await Promise.all(files.map(file
               => getFileData(currentDir, file)));    
    
          Taint flows through these intermediate variables:
    
          127┆ async function getFileData(currentDir,
               file) {                               
    
          then reaches:
    
          128┆ const pathToFile = path.join(currentDir,
               file);                                  
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.express-fs-filename.express-fs-filename[0m
          The application builds a file path from          
          potentially untrusted data, which can lead to a  
          path traversal vulnerability. An attacker can    
          manipulate the file path which the application   
          uses to access files. If the application does not
          validate user input and sanitize file paths,     
          sensitive files such as configuration or user    
          data can be accessed, potentially creating or    
          overwriting files. To prevent this vulnerability,
          validate and sanitize any input that is used to  
          create references to file paths. Also, enforce   
          strict file access controls. For example, choose 
          privileges allowing public-facing applications to
          access only the required files.                  
          Details: https://sg.run/0B9W                     
                                                           
          129┆ const stat = await           
               fs.promises.stat(pathToFile);
    
    
          Taint comes from:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
          Taint flows through these intermediate variables:
    
           20┆ const currentFolder =              
               path.join(nconf.get('upload_path'),
               req.query.dir || '');              
    
    
                This is how taint reaches the sink:
    
           40┆ files = await filesToData(currentFolder,
               files);                                 
    
          Taint flows through these intermediate variables:
    
          123┆ async function filesToData(currentDir,
               files) {                              
    
          then call to:
    
          124┆ return await Promise.all(files.map(file
               => getFileData(currentDir, file)));    
    
          Taint flows through these intermediate variables:
    
          127┆ async function getFileData(currentDir,
               file) {                               
    
          128┆ const pathToFile = path.join(currentDir,
               file);                                  
    
          then reaches:
    
          129┆ const stat = await           
               fs.promises.stat(pathToFile);
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
          231┆ if (!await file.exists(path.join(nconf.g
               et('upload_path'), params.folder))) {   
    
    
          Taint comes from:
    
          225┆ params = JSON.parse(req.body.params);
    
    
          Taint flows through these intermediate variables:
    
          225┆ params = JSON.parse(req.body.params);
    
    
                This is how taint reaches the sink:
    
          231┆ if (!await file.exists(path.join(nconf.g
               et('upload_path'), params.folder))) {   
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          231┆ if (!await file.exists(path.join(nconf.g
               et('upload_path'), params.folder))) {   
    
    
          Taint comes from:
    
          221┆ uploadsController.uploadFile = async
               function (req, res, next) {         
    
    
          Taint flows through these intermediate variables:
    
          221┆ uploadsController.uploadFile = async
               function (req, res, next) {         
    
          225┆ params = JSON.parse(req.body.params);
    
    
                This is how taint reaches the sink:
    
          231┆ if (!await file.exists(path.join(nconf.g
               et('upload_path'), params.folder))) {   
    
    
            ⋮┆----------------------------------------
          281┆ const uploadPath =                 
               path.join(nconf.get('upload_path'),
               folder, 'site-logo-x50.png');      
    
    
          Taint comes from:
    
          271┆ async function uploadImage(filename,   
               folder, uploadedFile, req, res, next) {
    
    
          Taint flows through these intermediate variables:
    
          271┆ async function uploadImage(filename,   
               folder, uploadedFile, req, res, next) {
    
    
                This is how taint reaches the sink:
    
          281┆ const uploadPath =                 
               path.join(nconf.get('upload_path'),
               folder, 'site-logo-x50.png');      
    
                                                 
  [36m[22m[24m  src/controllers/admin/users.js[0m
   ❯❯❱ [1mjavascript.express.security.audit.remote-property-[0m
  [1m     injection.remote-property-injection[0m               
          Bracket object notation with user input is     
          present, this might allow an attacker to access
          all properties of the object and even it's     
          prototype. Use literal values for object       
          properties.                                    
          Details: https://sg.run/Z4gn                   
                                                         
          262┆ data[`sort_${data.sortBy}`] = true;
    
    
          Taint comes from:
    
          165┆ searchData.sortBy = req.query.sortBy;
    
    
          Taint flows through these intermediate variables:
    
          165┆ searchData.sortBy = req.query.sortBy;
    
    
                This is how taint reaches the sink:
    
          167┆ await render(req, res, searchData);
    
          Taint flows through these intermediate variables:
    
          255┆ async function render(req, res, data) {
    
          262┆ data[`sort_${data.sortBy}`] = true;
    
          then reaches:
    
          262┆ data[`sort_${data.sortBy}`] = true;
    
    
            ⋮┆----------------------------------------
          264┆ data[`searchBy_${validator.escape(String
               (req.query.searchBy))}`] = true;        
    
    
          Taint comes from:
    
          264┆ data[`searchBy_${validator.escape(String
               (req.query.searchBy))}`] = true;        
    
    
          Taint flows through these intermediate variables:
    
          264┆ data[`searchBy_${validator.escape(String
               (req.query.searchBy))}`] = true;        
    
    
                This is how taint reaches the sink:
    
          264┆ data[`searchBy_${validator.escape(String
               (req.query.searchBy))}`] = true;        
    
                                            
  [36m[22m[24m  src/controllers/groups.js[0m
    ❯❱ [1mjavascript.express.web.tainted-redirect-express.tainted-[0m
  [1m     redirect-express[0m                                        
          The application builds a URL using user-         
          controlled input which can lead to an open       
          redirect vulnerability. An attacker can          
          manipulate the URL and redirect users to an      
          arbitrary domain. Open redirect vulnerabilities  
          can lead to issues such as Cross-site scripting  
          (XSS) or redirecting to a malicious domain for   
          activities such as phishing to capture users'    
          credentials. To prevent this vulnerability       
          perform strict input validation of the domain    
          against an allowlist of approved domains. Notify 
          a user in your application that they are leaving 
          the website. Display a domain where they are     
          redirected to the user. A user can then either   
          accept or deny the redirect to an untrusted site.
          Details: https://sg.run/7KEAw                    
                                                           
           76┆ return res.redirect(`${nconf.get('relati
               ve_path')}/groups/${lowercaseSlug}`);   
    
    
          Taint comes from:
    
           71┆ const lowercaseSlug =         
               req.params.slug.toLowerCase();
    
    
          Taint flows through these intermediate variables:
    
           71┆ const lowercaseSlug =         
               req.params.slug.toLowerCase();
    
    
                This is how taint reaches the sink:
    
           76┆ return res.redirect(`${nconf.get('relati
               ve_path')}/groups/${lowercaseSlug}`);   
    
                                          
  [36m[22m[24m  src/controllers/home.js[0m
    ❯❱ [1mjavascript.express.security.express-data-[0m
  [1m     exfiltration.express-data-exfiltration[0m   
          Depending on the context, user control data in   
          `Object.assign` can cause web response to include
          data that it should not have or can lead to a    
          mass assignment vulnerability.                   
          Details: https://sg.run/pkpL                     
                                                           
           47┆ req.query =                   
               Object.assign(parsedUrl.query,
               req.query);                   
    
    
          Taint comes from:
    
           47┆ req.query =                   
               Object.assign(parsedUrl.query,
               req.query);                   
    
    
                This is how taint reaches the sink:
    
           47┆ req.query =                   
               Object.assign(parsedUrl.query,
               req.query);                   
    
    
            ⋮┆----------------------------------------
   
   ❯❯❱ [1mjavascript.express.object.object-assign-express.object-[0m
  [1m     assign-express[0m                                         
          JSON injection occurs when untrusted input is   
          incorporated into a JavaScript object without   
          proper validation or sanitization. When using   
          methods like Object.assign, malicious input can 
          override or add unintended properties to the    
          object. Attackers may inject properties that    
          alter the application's behavior. Validate the  
          structure and content of input data to ensure it
          adheres to expected schemas. Reject inputs      
          containing unexpected or disallowed properties. 
          Details: https://sg.run/wdR8n                   
                                                          
           47┆ req.query =                   
               Object.assign(parsedUrl.query,
               req.query);                   
    
    
          Taint comes from:
    
           47┆ req.query =                   
               Object.assign(parsedUrl.query,
               req.query);                   
    
    
                This is how taint reaches the sink:
    
           47┆ req.query =                   
               Object.assign(parsedUrl.query,
               req.query);                   
    
                                          
  [36m[22m[24m  src/controllers/mods.js[0m
   ❯❯❱ [1mjavascript.express.security.audit.remote-property-[0m
  [1m     injection.remote-property-injection[0m               
          Bracket object notation with user input is     
          present, this might allow an attacker to access
          all properties of the object and even it's     
          prototype. Use literal values for object       
          properties.                                    
          Details: https://sg.run/Z4gn                   
                                                         
           47┆ memo[cur] = validator.escape(String(req.
               query[cur].trim()));                    
    
    
          Taint comes from:
    
           47┆ memo[cur] = validator.escape(String(req.
               query[cur].trim()));                    
    
    
                This is how taint reaches the sink:
    
           47┆ memo[cur] = validator.escape(String(req.
               query[cur].trim()));                    
    
    
            ⋮┆----------------------------------------
           49┆ memo[cur] = req.query[cur].map(item => 
               validator.escape(String(item).trim()));
    
    
          Taint comes from:
    
           49┆ memo[cur] = req.query[cur].map(item => 
               validator.escape(String(item).trim()));
    
    
                This is how taint reaches the sink:
    
           49┆ memo[cur] = req.query[cur].map(item => 
               validator.escape(String(item).trim()));
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.express-data-[0m
  [1m     exfiltration.express-data-exfiltration[0m   
          Depending on the context, user control data in   
          `Object.assign` can cause web response to include
          data that it should not have or can lead to a    
          mass assignment vulnerability.                   
          Details: https://sg.run/pkpL                     
                                                           
          190┆ res.render('flags/detail',       
               Object.assign(results.flagData, {
          191┆    assignees: assignees,
          192┆    type_bool: ['post', 'user',  
               'empty'].reduce((memo, cur) => {
          193┆            if (cur !== 'empty') {
          194┆                    memo[cur] =    
               results.flagData.type === cur && (
          195┆                            
               !results.flagData.target ||
          196┆                                         
               !!Object.keys(results.flagData.target).l
               ength                                   
          197┆                    );
          198┆            } else {
          199┆                    memo[cur] =          
               !Object.keys(results.flagData.target).le
               ngth;                                   
             [hid 12 additional lines, adjust with                   
  --max-lines-per-finding]                                           
    
    
          Taint comes from:
    
          135┆ flagData: flags.get(req.params.flagId),
    
    
          Taint flows through these intermediate variables:
    
          132┆ const results = await  
               utils.promiseParallel({
    
          132┆ const results = await  
               utils.promiseParallel({
    
    
                This is how taint reaches the sink:
    
          190┆ res.render('flags/detail',       
               Object.assign(results.flagData, {
    
          191┆    assignees: assignees,
    
          192┆    type_bool: ['post', 'user',  
               'empty'].reduce((memo, cur) => {
    
          193┆            if (cur !== 'empty') {
    
          194┆                    memo[cur] =    
               results.flagData.type === cur && (
    
          195┆                            
               !results.flagData.target ||
    
          196┆                                         
               !!Object.keys(results.flagData.target).l
               ength                                   
    
          197┆                    );
    
          198┆            } else {
    
          199┆                    memo[cur] =          
               !Object.keys(results.flagData.target).le
               ngth;                                   
    
             [hid 12 additional lines, adjust with                   
  --max-lines-per-finding]                                           
    
                                           
  [36m[22m[24m  src/controllers/users.js[0m
   ❯❯❱ [1mjavascript.express.security.audit.remote-property-[0m
  [1m     injection.remote-property-injection[0m               
          Bracket object notation with user input is     
          present, this might allow an attacker to access
          all properties of the object and even it's     
          prototype. Use literal values for object       
          properties.                                    
          Details: https://sg.run/Z4gn                   
                                                         
           45┆ searchData[`section_${section}`] = true;
    
    
          Taint comes from:
    
           44┆ searchData.pagination =          
               pagination.create(req.query.page,
               searchData.pageCount, req.query);
    
    
          Taint flows through these intermediate variables:
    
           44┆ searchData.pagination =          
               pagination.create(req.query.page,
               searchData.pageCount, req.query);
    
    
                This is how taint reaches the sink:
    
           45┆ searchData[`section_${section}`] = true;
    
                                                 
  [36m[22m[24m  src/controllers/write/admin.js[0m
   ❯❯❱ [1mjavascript.express.security.express-wkhtml-[0m
  [1m     injection.express-wkhtmltoimage-injection[0m  
          If unverified user data can reach the `phantom`
          methods it can result in Server-Side Request   
          Forgery vulnerabilities                        
          Details: https://sg.run/pxe0                   
                                                         
           36┆ const token = await             
               api.utils.tokens.generate({ uid,
               description });                 
    
    
          Taint comes from:
    
           35┆ const { uid, description } = req.body;
    
    
          Taint flows through these intermediate variables:
    
           35┆ const { uid, description } = req.body;
    
           35┆ const { uid, description } = req.body;
    
    
                This is how taint reaches the sink:
    
           36┆ const token = await             
               api.utils.tokens.generate({ uid,
               description });                 
    
                                                 
  [36m[22m[24m  src/controllers/write/posts.js[0m
    ❯❱ [1mjavascript.express.web.tainted-redirect-express.tainted-[0m
  [1m     redirect-express[0m                                        
          The application builds a URL using user-         
          controlled input which can lead to an open       
          redirect vulnerability. An attacker can          
          manipulate the URL and redirect users to an      
          arbitrary domain. Open redirect vulnerabilities  
          can lead to issues such as Cross-site scripting  
          (XSS) or redirecting to a malicious domain for   
          activities such as phishing to capture users'    
          credentials. To prevent this vulnerability       
          perform strict input validation of the domain    
          against an allowlist of approved domains. Notify 
          a user in your application that they are leaving 
          the website. Display a domain where they are     
          redirected to the user. A user can then either   
          accept or deny the redirect to an untrusted site.
          Details: https://sg.run/7KEAw                    
                                                           
           35┆ res.redirect(308,                       
               nconf.get('relative_path') + encodeURI(`
               /api/v3/posts/${pid}/${path}${urlObj.sea
               rch}`));                                
    
    
          Taint comes from:
    
           14┆ const { tid } = req.query || req.body;
    
    
          Taint flows through these intermediate variables:
    
           14┆ const { tid } = req.query || req.body;
    
           14┆ const { tid } = req.query || req.body;
    
           24┆ pid = await topics.getTopicField(tid,
               'mainPid');                          
    
           24┆ pid = await topics.getTopicField(tid,
               'mainPid');                          
    
           35┆ res.redirect(308,                       
               nconf.get('relative_path') + encodeURI(`
               /api/v3/posts/${pid}/${path}${urlObj.sea
               rch}`));                                
    
    
                This is how taint reaches the sink:
    
           35┆ res.redirect(308,                       
               nconf.get('relative_path') + encodeURI(`
               /api/v3/posts/${pid}/${path}${urlObj.sea
               rch}`));                                
    
                                                 
  [36m[22m[24m  src/controllers/write/users.js[0m
    ❯❱ [1mjavascript.express.web.tainted-redirect-express.tainted-[0m
  [1m     redirect-express[0m                                        
          The application builds a URL using user-         
          controlled input which can lead to an open       
          redirect vulnerability. An attacker can          
          manipulate the URL and redirect users to an      
          arbitrary domain. Open redirect vulnerabilities  
          can lead to issues such as Cross-site scripting  
          (XSS) or redirecting to a malicious domain for   
          activities such as phishing to capture users'    
          credentials. To prevent this vulnerability       
          perform strict input validation of the domain    
          against an allowlist of approved domains. Notify 
          a user in your application that they are leaving 
          the website. Display a domain where they are     
          redirected to the user. A user can then either   
          accept or deny the redirect to an untrusted site.
          Details: https://sg.run/7KEAw                    
                                                           
           20┆ res.redirect(308,                       
               nconf.get('relative_path') + encodeURI(`
               /api/v3/users/${uid}/${path}${urlObj.sea
               rch}`));                                
    
    
          Taint comes from:
    
           15┆ const uid = await                       
               user.getUidByUserslug(req.params.userslu
               g);                                     
    
    
          Taint flows through these intermediate variables:
    
           15┆ const uid = await                       
               user.getUidByUserslug(req.params.userslu
               g);                                     
    
           15┆ const uid = await                       
               user.getUidByUserslug(req.params.userslu
               g);                                     
    
           20┆ res.redirect(308,                       
               nconf.get('relative_path') + encodeURI(`
               /api/v3/users/${uid}/${path}${urlObj.sea
               rch}`));                                
    
    
                This is how taint reaches the sink:
    
           20┆ res.redirect(308,                       
               nconf.get('relative_path') + encodeURI(`
               /api/v3/users/${uid}/${path}${urlObj.sea
               rch}`));                                
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.node-stdlib.cryptography.crypto-weak-[0m
  [1m     algorithm.crypto-weak-algorithm[0m                 
          The use of a weak cryptographic algorithm (e.g., 
          SHA-1 or MD5) has been identified. These         
          algorithms are considered insecure due to        
          vulnerabilities that make them susceptible to    
          collision attacks, allowing attackers to         
          compromise data integrity or security. Replace   
          SHA-1 or MD5 with secure hashing algorithms, such
          as: SHA-256 or higher (e.g., SHA-3).             
          Details: https://sg.run/nJgp1                    
                                                           
          211┆ res.set('ETag', `"${crypto.createHash('m
               d5').update(String(stat.mtimeMs)).digest
               ('hex')}"`);                            
    
    
          Taint comes from:
    
          211┆ res.set('ETag', `"${crypto.createHash('m
               d5').update(String(stat.mtimeMs)).digest
               ('hex')}"`);                            
    
    
                This is how taint reaches the sink:
    
          211┆ res.set('ETag', `"${crypto.createHash('m
               d5').update(String(stat.mtimeMs)).digest
               ('hex')}"`);                            
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.audit.express-res-[0m
  [1m     sendfile.express-res-sendfile[0m                 
          The application processes user-input, this is   
          passed to res.sendFile which can allow an       
          attacker to arbitrarily read files on the system
          through path traversal. It is recommended to    
          perform input validation in addition to         
          canonicalizing the path. This allows you to     
          validate the path against the intended directory
          it should be accessing.                         
          Details: https://sg.run/7DJk                    
                                                          
          222┆ res.sendFile(data.filename, {
    
    
          Taint comes from:
    
          216┆ const data = await               
               api.users.getExportByType(req, ({
               ...req.params }));               
    
    
          Taint flows through these intermediate variables:
    
          216┆ const data = await               
               api.users.getExportByType(req, ({
               ...req.params }));               
    
          216┆ const data = await               
               api.users.getExportByType(req, ({
               ...req.params }));               
    
    
                This is how taint reaches the sink:
    
          222┆ res.sendFile(data.filename, {
    
                                             
  [36m[22m[24m  src/database/mongo/main.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `params` function         
          argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS)     
          within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use
          hardcoded regexes instead. If your regex is run  
          on user-controlled input, consider performing    
          input validation or use a regex                  
          checking/sanitization library such as            
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
           44┆ '_key', { _key: { $regex: new
               RegExp(match) } }            
    
    
          Taint comes from:
    
           41┆ module.scan = async function (params) {
    
    
          Taint flows through these intermediate variables:
    
           41┆ module.scan = async function (params) {
    
           42┆ const match =                         
               helpers.buildMatchQuery(params.match);
    
    
                This is how taint reaches the sink:
    
           44┆ '_key', { _key: { $regex: new
               RegExp(match) } }            
    
                                               
  [36m[22m[24m  src/database/mongo/sorted.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `params` function         
          argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS)     
          within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use
          hardcoded regexes instead. If your regex is run  
          on user-controlled input, consider performing    
          input validation or use a regex                  
          checking/sanitization library such as            
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          549┆ regex = new RegExp(match);
    
    
          Taint comes from:
    
          540┆ module.getSortedSetScan = async function
               (params) {                              
    
    
          Taint flows through these intermediate variables:
    
          540┆ module.getSortedSetScan = async function
               (params) {                              
    
          546┆ const match =                         
               helpers.buildMatchQuery(params.match);
    
    
                This is how taint reaches the sink:
    
          549┆ regex = new RegExp(match);
    
                                 
  [36m[22m[24m  src/emailer.js[0m
    ❯❱ [1mproblem-based-packs.insecure-transport.js-node.bypass-tls-[0m
  [1m     verification.bypass-tls-verification[0m                      
          Checks for setting the environment variable      
          NODE_TLS_REJECT_UNAUTHORIZED to 0, which disables
          TLS verification. This should only be used for   
          debugging purposes. Setting the option           
          rejectUnauthorized to false bypasses verification
          against the list of trusted CAs, which also leads
          to insecure transport. These options lead to     
          vulnerability to MTM attacks, and should not be  
          used.                                            
          Details: https://sg.run/9oxr                     
                                                           
          157┆ smtpOptions.tls = {
          158┆    rejectUnauthorized: false,
          159┆ };
                              
  [36m[22m[24m  src/file.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           24┆ const uploadPath =                 
               path.join(nconf.get('upload_path'),
               folder, filename);                 
    
    
          Taint comes from:
    
           18┆ file.saveFileToLocal = async function
               (filename, folder, tempPath) {       
    
    
          Taint flows through these intermediate variables:
    
           18┆ file.saveFileToLocal = async function
               (filename, folder, tempPath) {       
    
    
                This is how taint reaches the sink:
    
           24┆ const uploadPath =                 
               path.join(nconf.get('upload_path'),
               folder, filename);                 
    
    
            ⋮┆----------------------------------------
           24┆ const uploadPath =                 
               path.join(nconf.get('upload_path'),
               folder, filename);                 
    
    
          Taint comes from:
    
           18┆ file.saveFileToLocal = async function
               (filename, folder, tempPath) {       
    
    
          Taint flows through these intermediate variables:
    
           18┆ file.saveFileToLocal = async function
               (filename, folder, tempPath) {       
    
    
                This is how taint reaches the sink:
    
           24┆ const uploadPath =                 
               path.join(nconf.get('upload_path'),
               folder, filename);                 
    
    
            ⋮┆----------------------------------------
          157┆ const res = path.resolve(dir, subdir);
    
    
          Taint comes from:
    
          154┆ file.walk = async function (dir) {
    
    
          Taint flows through these intermediate variables:
    
          154┆ file.walk = async function (dir) {
    
    
                This is how taint reaches the sink:
    
          157┆ const res = path.resolve(dir, subdir);
    
    
            ⋮┆----------------------------------------
          157┆ const res = path.resolve(dir, subdir);
    
    
          Taint comes from:
    
          154┆ file.walk = async function (dir) {
    
    
          Taint flows through these intermediate variables:
    
          154┆ file.walk = async function (dir) {
    
          155┆ const subdirs = await    
               fs.promises.readdir(dir);
    
          155┆ const subdirs = await    
               fs.promises.readdir(dir);
    
          156┆ const files = await                   
               Promise.all(subdirs.map(async (subdir)
               => {                                  
    
    
                This is how taint reaches the sink:
    
          157┆ const res = path.resolve(dir, subdir);
    
                                      
  [36m[22m[24m  src/groups/cover.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           74┆ const filePath =                   
               path.join(nconf.get('upload_path'),
               'files', filename);                
    
    
          Taint comes from:
    
           11┆ module.exports = function (Groups) {
    
    
          Taint flows through these intermediate variables:
    
           11┆ module.exports = function (Groups) {
    
           68┆ const values = await                 
               Groups.getGroupFields(data.groupName,
               fields);                             
    
           68┆ const values = await                 
               Groups.getGroupFields(data.groupName,
               fields);                             
    
           73┆ const filename =               
               values[field].split('/').pop();
    
    
                This is how taint reaches the sink:
    
           74┆ const filePath =                   
               path.join(nconf.get('upload_path'),
               'files', filename);                
    
                               
  [36m[22m[24m  src/image.js[0m
    ❯❱ [1mjavascript.node-stdlib.cryptography.crypto-weak-[0m
  [1m     algorithm.crypto-weak-algorithm[0m                 
          The use of a weak cryptographic algorithm (e.g., 
          SHA-1 or MD5) has been identified. These         
          algorithms are considered insecure due to        
          vulnerabilities that make them susceptible to    
          collision attacks, allowing attackers to         
          compromise data integrity or security. Replace   
          SHA-1 or MD5 with secure hashing algorithms, such
          as: SHA-256 or higher (e.g., SHA-3).             
          Details: https://sg.run/nJgp1                    
                                                           
          147┆ const filename = crypto.createHash('md5'
               ).update(imageData).digest('hex');      
    
    
          Taint comes from:
    
          147┆ const filename = crypto.createHash('md5'
               ).update(imageData).digest('hex');      
    
    
                This is how taint reaches the sink:
    
          147┆ const filename = crypto.createHash('md5'
               ).update(imageData).digest('hex');      
    
                                   
  [36m[22m[24m  src/languages.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           16┆ const pathToLanguageFile =        
               path.join(languagesPath, language,
               `${namespace}.json`);             
    
    
          Taint comes from:
    
           15┆ Languages.get = async function
               (language, namespace) {       
    
    
          Taint flows through these intermediate variables:
    
           15┆ Languages.get = async function
               (language, namespace) {       
    
    
                This is how taint reaches the sink:
    
           16┆ const pathToLanguageFile =        
               path.join(languagesPath, language,
               `${namespace}.json`);             
    
    
            ⋮┆----------------------------------------
           16┆ const pathToLanguageFile =        
               path.join(languagesPath, language,
               `${namespace}.json`);             
    
    
          Taint comes from:
    
           15┆ Languages.get = async function
               (language, namespace) {       
    
    
          Taint flows through these intermediate variables:
    
           15┆ Languages.get = async function
               (language, namespace) {       
    
    
                This is how taint reaches the sink:
    
           16┆ const pathToLanguageFile =        
               path.join(languagesPath, language,
               `${namespace}.json`);             
    
    
            ⋮┆----------------------------------------
           59┆ const configPath =              
               path.join(languagesPath, folder,
               'language.json');               
    
    
          Taint comes from:
    
           57┆ let languages = await                  
               Promise.all(codes.map(async (folder) =>
               {                                      
    
    
          Taint flows through these intermediate variables:
    
           57┆ let languages = await                  
               Promise.all(codes.map(async (folder) =>
               {                                      
    
    
                This is how taint reaches the sink:
    
           59┆ const configPath =              
               path.join(languagesPath, folder,
               'language.json');               
    
                                
  [36m[22m[24m  src/logger.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           80┆ stream =                             
               fs.createWriteStream(path.join(value,
               'nodebb.log'), { flags: 'a' });      
    
    
          Taint comes from:
    
           72┆ Logger.open = function (value) {
    
    
          Taint flows through these intermediate variables:
    
           72┆ Logger.open = function (value) {
    
    
                This is how taint reaches the sink:
    
           80┆ stream =                             
               fs.createWriteStream(path.join(value,
               'nodebb.log'), { flags: 'a' });      
    
                                      
  [36m[22m[24m  src/meta/configs.js[0m
    ❯❱ [1mjavascript.lang.security.insecure-object-assign.insecure-[0m
  [1m     object-assign[0m                                            
          Depending on the context, user control data in   
          `Object.assign` can cause web response to include
          data that it should not have or can lead to a    
          mass assignment vulnerability.                   
          Details: https://sg.run/2R0D                     
                                                           
          245┆ Object.assign(Meta.config, config);
    
    
          Taint comes from:
    
          136┆ updateConfig(deserialize(data));
    
          Taint flows through these intermediate variables:
    
           44┆ deserialized[key] =             
               JSON.parse(config[key] || '[]');
    
           27┆ deserialized[key] = String(config[key]);
    
          then reaches:
    
           44┆ deserialized[key] =             
               JSON.parse(config[key] || '[]');
    
    
                This is how taint reaches the sink:
    
          136┆ updateConfig(deserialize(data));
    
          Taint flows through these intermediate variables:
    
          239┆ function updateConfig(config) {
    
          then call to:
    
          240┆ updateLocalConfig(config);
    
          Taint flows through these intermediate variables:
    
          244┆ function updateLocalConfig(config) {
    
          then reaches:
    
          245┆ Object.assign(Meta.config, config);
    
                                  
  [36m[22m[24m  src/meta/css.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          160┆ const exists = await             
               file.exists(path.join(__dirname, 
               '../../node_modules', filepath));
    
    
          Taint comes from:
    
          157┆ async function                 
               filterMissingFiles(filepaths) {
    
    
          Taint flows through these intermediate variables:
    
          157┆ async function                 
               filterMissingFiles(filepaths) {
    
          159┆ filepaths.map(async (filepath) => {
    
    
                This is how taint reaches the sink:
    
          160┆ const exists = await             
               file.exists(path.join(__dirname, 
               '../../node_modules', filepath));
    
    
            ⋮┆----------------------------------------
          180┆ const newFile = path.join(parsed.dir,
               parsed.name);                        
    
    
          Taint comes from:
    
          174┆ function pathToImport(file) {
    
    
          Taint flows through these intermediate variables:
    
          174┆ function pathToImport(file) {
    
          179┆ const parsed = path.parse(file);
    
    
                This is how taint reaches the sink:
    
          180┆ const newFile = path.join(parsed.dir,
               parsed.name);                        
    
    
            ⋮┆----------------------------------------
          180┆ const newFile = path.join(parsed.dir,
               parsed.name);                        
    
    
          Taint comes from:
    
          174┆ function pathToImport(file) {
    
    
          Taint flows through these intermediate variables:
    
          174┆ function pathToImport(file) {
    
          179┆ const parsed = path.parse(file);
    
    
                This is how taint reaches the sink:
    
          180┆ const newFile = path.join(parsed.dir,
               parsed.name);                        
    
    
            ⋮┆----------------------------------------
          336┆ await Promise.all(files.map(f =>       
               fs.promises.unlink(path.join(__dirname,
               '../../build/public', f))));           
    
    
          Taint comes from:
    
          336┆ await Promise.all(files.map(f =>       
               fs.promises.unlink(path.join(__dirname,
               '../../build/public', f))));           
    
    
          Taint flows through these intermediate variables:
    
          336┆ await Promise.all(files.map(f =>       
               fs.promises.unlink(path.join(__dirname,
               '../../build/public', f))));           
    
    
                This is how taint reaches the sink:
    
          336┆ await Promise.all(files.map(f =>       
               fs.promises.unlink(path.join(__dirname,
               '../../build/public', f))));           
    
    
            ⋮┆----------------------------------------
          344┆                                         
               fs.promises.writeFile(path.join(__dirnam
               e, '../../build/public',                
               `${target}.css`), ltr.code),            
    
    
          Taint comes from:
    
          332┆ CSS.buildBundle = async function
               (target, fork) {                
    
    
          Taint flows through these intermediate variables:
    
          332┆ CSS.buildBundle = async function
               (target, fork) {                
    
    
                This is how taint reaches the sink:
    
          344┆                                         
               fs.promises.writeFile(path.join(__dirnam
               e, '../../build/public',                
               `${target}.css`), ltr.code),            
    
    
            ⋮┆----------------------------------------
          345┆                                         
               fs.promises.writeFile(path.join(__dirnam
               e, '../../build/public',                
               `${target}-rtl.css`), rtl.code),        
    
    
          Taint comes from:
    
          332┆ CSS.buildBundle = async function
               (target, fork) {                
    
    
          Taint flows through these intermediate variables:
    
          332┆ CSS.buildBundle = async function
               (target, fork) {                
    
    
                This is how taint reaches the sink:
    
          345┆                                         
               fs.promises.writeFile(path.join(__dirnam
               e, '../../build/public',                
               `${target}-rtl.css`), rtl.code),        
    
                                           
  [36m[22m[24m  src/meta/dependencies.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           34┆ let pkgData = await fs.promises.readFile
               (path.join(paths.nodeModules,           
               moduleName, 'package.json'), 'utf8');   
    
    
          Taint comes from:
    
           32┆ Dependencies.checkModule = async
               function (moduleName) {         
    
    
          Taint flows through these intermediate variables:
    
           32┆ Dependencies.checkModule = async
               function (moduleName) {         
    
    
                This is how taint reaches the sink:
    
           34┆ let pkgData = await fs.promises.readFile
               (path.join(paths.nodeModules,           
               moduleName, 'package.json'), 'utf8');   
    
                                 
  [36m[22m[24m  src/meta/js.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           37┆ const srcPath = path.join(__dirname,
               '../../', modules[relPath]);        
    
    
          Taint comes from:
    
           36┆ await                                   
               Promise.all(Object.keys(modules).map(asy
               nc (relPath) => {                       
    
    
          Taint flows through these intermediate variables:
    
           36┆ await                                   
               Promise.all(Object.keys(modules).map(asy
               nc (relPath) => {                       
    
    
                This is how taint reaches the sink:
    
           37┆ const srcPath = path.join(__dirname,
               '../../', modules[relPath]);        
    
    
            ⋮┆----------------------------------------
           38┆ const destPath = path.join(__dirname,
               '../../build/public/src/modules',    
               relPath);                            
    
    
          Taint comes from:
    
           36┆ await                                   
               Promise.all(Object.keys(modules).map(asy
               nc (relPath) => {                       
    
    
          Taint flows through these intermediate variables:
    
           36┆ await                                   
               Promise.all(Object.keys(modules).map(asy
               nc (relPath) => {                       
    
    
                This is how taint reaches the sink:
    
           38┆ const destPath = path.join(__dirname,
               '../../build/public/src/modules',    
               relPath);                            
    
    
            ⋮┆----------------------------------------
           65┆ p => path.join(__dirname,   
               '../../build/public/src', p)
    
    
          Taint comes from:
    
           65┆ p => path.join(__dirname,   
               '../../build/public/src', p)
    
    
          Taint flows through these intermediate variables:
    
           65┆ p => path.join(__dirname,   
               '../../build/public/src', p)
    
    
                This is how taint reaches the sink:
    
           65┆ p => path.join(__dirname,   
               '../../build/public/src', p)
    
    
            ⋮┆----------------------------------------
           92┆ const destDir = path.join(__dirname,
               '../../build/public/plugins',       
               mappedPath);                        
    
    
          Taint comes from:
    
           90┆ await Promise.all(Object.keys(plugins.st
               aticDirs).map(async (mappedPath) => {   
    
    
          Taint flows through these intermediate variables:
    
           90┆ await Promise.all(Object.keys(plugins.st
               aticDirs).map(async (mappedPath) => {   
    
    
                This is how taint reaches the sink:
    
           92┆ const destDir = path.join(__dirname,
               '../../build/public/plugins',       
               mappedPath);                        
    
    
            ⋮┆----------------------------------------
          133┆ const filePath = path.join(__dirname,
               '../../build/public', filename);     
    
    
          Taint comes from:
    
          130┆ JS.buildBundle = async function (target,
               fork) {                                 
    
    
          Taint flows through these intermediate variables:
    
          130┆ JS.buildBundle = async function (target,
               fork) {                                 
    
          131┆ const filename = `scripts-${target}.js`;
    
          131┆ const filename = `scripts-${target}.js`;
    
    
                This is how taint reaches the sink:
    
          133┆ const filePath = path.join(__dirname,
               '../../build/public', filename);     
    
                                        
  [36m[22m[24m  src/meta/languages.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           59┆ const filePath =                       
               path.join(buildLanguagesPath, language,
               `${namespace}.json`);                  
    
    
          Taint comes from:
    
           57┆ async function                        
               writeLanguageFile(language, namespace,
               translations) {                       
    
    
          Taint flows through these intermediate variables:
    
           57┆ async function                        
               writeLanguageFile(language, namespace,
               translations) {                       
    
    
                This is how taint reaches the sink:
    
           59┆ const filePath =                       
               path.join(buildLanguagesPath, language,
               `${namespace}.json`);                  
    
    
            ⋮┆----------------------------------------
           59┆ const filePath =                       
               path.join(buildLanguagesPath, language,
               `${namespace}.json`);                  
    
    
          Taint comes from:
    
           57┆ async function                        
               writeLanguageFile(language, namespace,
               translations) {                       
    
    
          Taint flows through these intermediate variables:
    
           57┆ async function                        
               writeLanguageFile(language, namespace,
               translations) {                       
    
    
                This is how taint reaches the sink:
    
           59┆ const filePath =                       
               path.join(buildLanguagesPath, language,
               `${namespace}.json`);                  
    
    
            ⋮┆----------------------------------------
           87┆ await                                 
               assignFileToTranslations(translations,
               path.join(coreLanguagesPath, lang,    
               `${namespace}.json`));                
    
    
          Taint comes from:
    
           68┆ async function buildTranslations(ref) {
    
    
          Taint flows through these intermediate variables:
    
           68┆ async function buildTranslations(ref) {
    
           70┆ const { languages } = ref;
    
           76┆ languages.forEach((language) => {
    
    
                This is how taint reaches the sink:
    
           77┆ promises.push(buildNamespaceLanguage(lan
               guage, namespace, plugins));            
    
          Taint flows through these intermediate variables:
    
           84┆ async function                         
               buildNamespaceLanguage(lang, namespace,
               plugins) {                             
    
          then reaches:
    
           87┆ await                                 
               assignFileToTranslations(translations,
               path.join(coreLanguagesPath, lang,    
               `${namespace}.json`));                
    
    
            ⋮┆----------------------------------------
           87┆ await                                 
               assignFileToTranslations(translations,
               path.join(coreLanguagesPath, lang,    
               `${namespace}.json`));                
    
    
          Taint comes from:
    
           68┆ async function buildTranslations(ref) {
    
    
          Taint flows through these intermediate variables:
    
           68┆ async function buildTranslations(ref) {
    
           69┆ const { namespaces } = ref;
    
           75┆ namespaces.forEach((namespace) => {
    
    
                This is how taint reaches the sink:
    
           77┆ promises.push(buildNamespaceLanguage(lan
               guage, namespace, plugins));            
    
          Taint flows through these intermediate variables:
    
           84┆ async function                         
               buildNamespaceLanguage(lang, namespace,
               plugins) {                             
    
          then reaches:
    
           87┆ await                                 
               assignFileToTranslations(translations,
               path.join(coreLanguagesPath, lang,    
               `${namespace}.json`));                
    
    
            ⋮┆----------------------------------------
          102┆ const pathToPluginLanguageFolder =   
               path.join(paths.nodeModules,         
               pluginData.id, pluginData.languages);
    
    
          Taint comes from:
    
           84┆ async function                         
               buildNamespaceLanguage(lang, namespace,
               plugins) {                             
    
    
          Taint flows through these intermediate variables:
    
           84┆ async function                         
               buildNamespaceLanguage(lang, namespace,
               plugins) {                             
    
           89┆ await Promise.all(plugins.map(pluginData
               => addPlugin(translations, pluginData,  
               lang, namespace)));                     
    
    
                This is how taint reaches the sink:
    
           89┆ await Promise.all(plugins.map(pluginData
               => addPlugin(translations, pluginData,  
               lang, namespace)));                     
    
          Taint flows through these intermediate variables:
    
           96┆ async function addPlugin(translations,
               pluginData, lang, namespace) {        
    
          then reaches:
    
          102┆ const pathToPluginLanguageFolder =   
               path.join(paths.nodeModules,         
               pluginData.id, pluginData.languages);
    
    
            ⋮┆----------------------------------------
          102┆ const pathToPluginLanguageFolder =   
               path.join(paths.nodeModules,         
               pluginData.id, pluginData.languages);
    
    
          Taint comes from:
    
           84┆ async function                         
               buildNamespaceLanguage(lang, namespace,
               plugins) {                             
    
    
          Taint flows through these intermediate variables:
    
           84┆ async function                         
               buildNamespaceLanguage(lang, namespace,
               plugins) {                             
    
           89┆ await Promise.all(plugins.map(pluginData
               => addPlugin(translations, pluginData,  
               lang, namespace)));                     
    
    
                This is how taint reaches the sink:
    
           89┆ await Promise.all(plugins.map(pluginData
               => addPlugin(translations, pluginData,  
               lang, namespace)));                     
    
          Taint flows through these intermediate variables:
    
           96┆ async function addPlugin(translations,
               pluginData, lang, namespace) {        
    
          then reaches:
    
          102┆ const pathToPluginLanguageFolder =   
               path.join(paths.nodeModules,         
               pluginData.id, pluginData.languages);
    
    
            ⋮┆----------------------------------------
          119┆ await                                 
               assignFileToTranslations(translations,
               path.join(pathToPluginLanguageFolder, 
               language, `${namespace}.json`));      
    
    
          Taint comes from:
    
           84┆ async function                         
               buildNamespaceLanguage(lang, namespace,
               plugins) {                             
    
    
          Taint flows through these intermediate variables:
    
           84┆ async function                         
               buildNamespaceLanguage(lang, namespace,
               plugins) {                             
    
           89┆ await Promise.all(plugins.map(pluginData
               => addPlugin(translations, pluginData,  
               lang, namespace)));                     
    
    
                This is how taint reaches the sink:
    
           89┆ await Promise.all(plugins.map(pluginData
               => addPlugin(translations, pluginData,  
               lang, namespace)));                     
    
          Taint flows through these intermediate variables:
    
           96┆ async function addPlugin(translations,
               pluginData, lang, namespace) {        
    
          102┆ const pathToPluginLanguageFolder =   
               path.join(paths.nodeModules,         
               pluginData.id, pluginData.languages);
    
          then reaches:
    
          119┆ await                                 
               assignFileToTranslations(translations,
               path.join(pathToPluginLanguageFolder, 
               language, `${namespace}.json`));      
    
    
            ⋮┆----------------------------------------
          119┆ await                                 
               assignFileToTranslations(translations,
               path.join(pathToPluginLanguageFolder, 
               language, `${namespace}.json`));      
    
    
          Taint comes from:
    
           68┆ async function buildTranslations(ref) {
    
    
          Taint flows through these intermediate variables:
    
           68┆ async function buildTranslations(ref) {
    
           70┆ const { languages } = ref;
    
           76┆ languages.forEach((language) => {
    
    
                This is how taint reaches the sink:
    
           77┆ promises.push(buildNamespaceLanguage(lan
               guage, namespace, plugins));            
    
          Taint flows through these intermediate variables:
    
           84┆ async function                         
               buildNamespaceLanguage(lang, namespace,
               plugins) {                             
    
          then call to:
    
           89┆ await Promise.all(plugins.map(pluginData
               => addPlugin(translations, pluginData,  
               lang, namespace)));                     
    
          Taint flows through these intermediate variables:
    
           96┆ async function addPlugin(translations,
               pluginData, lang, namespace) {        
    
          110┆ const langs = _.uniq([
    
          117┆ for (const language of langs) {
    
          117┆ for (const language of langs) {
    
          then reaches:
    
          119┆ await                                 
               assignFileToTranslations(translations,
               path.join(pathToPluginLanguageFolder, 
               language, `${namespace}.json`));      
    
    
            ⋮┆----------------------------------------
          119┆ await                                 
               assignFileToTranslations(translations,
               path.join(pathToPluginLanguageFolder, 
               language, `${namespace}.json`));      
    
    
          Taint comes from:
    
           68┆ async function buildTranslations(ref) {
    
    
          Taint flows through these intermediate variables:
    
           68┆ async function buildTranslations(ref) {
    
           69┆ const { namespaces } = ref;
    
           75┆ namespaces.forEach((namespace) => {
    
    
                This is how taint reaches the sink:
    
           77┆ promises.push(buildNamespaceLanguage(lan
               guage, namespace, plugins));            
    
          Taint flows through these intermediate variables:
    
           84┆ async function                         
               buildNamespaceLanguage(lang, namespace,
               plugins) {                             
    
          then call to:
    
           89┆ await Promise.all(plugins.map(pluginData
               => addPlugin(translations, pluginData,  
               lang, namespace)));                     
    
          Taint flows through these intermediate variables:
    
           96┆ async function addPlugin(translations,
               pluginData, lang, namespace) {        
    
          then reaches:
    
          119┆ await                                 
               assignFileToTranslations(translations,
               path.join(pathToPluginLanguageFolder, 
               language, `${namespace}.json`));      
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.insecure-object-assign.insecure-[0m
  [1m     object-assign[0m                                            
          Depending on the context, user control data in   
          `Object.assign` can cause web response to include
          data that it should not have or can lead to a    
          mass assignment vulnerability.                   
          Details: https://sg.run/2R0D                     
                                                           
          126┆ Object.assign(translations,
               JSON.parse(fileData));     
    
    
          Taint comes from:
    
          126┆ Object.assign(translations,
               JSON.parse(fileData));     
    
    
                This is how taint reaches the sink:
    
          126┆ Object.assign(translations,
               JSON.parse(fileData));     
    
                                        
  [36m[22m[24m  src/meta/templates.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           51┆ return path.join(paths.nodeModules, id,
               plugins.pluginsData[id].templates ||   
               'templates');                          
    
    
          Taint comes from:
    
           43┆ async function                  
               getTemplateDirs(activePlugins) {
    
    
          Taint flows through these intermediate variables:
    
           43┆ async function                  
               getTemplateDirs(activePlugins) {
    
           44┆ const pluginTemplates =    
               activePlugins.map((id) => {
    
    
                This is how taint reaches the sink:
    
           51┆ return path.join(paths.nodeModules, id,
               plugins.pluginsData[id].templates ||   
               'templates');                          
    
    
            ⋮┆----------------------------------------
           51┆ return path.join(paths.nodeModules, id,
               plugins.pluginsData[id].templates ||   
               'templates');                          
    
    
          Taint comes from:
    
           43┆ async function                  
               getTemplateDirs(activePlugins) {
    
    
          Taint flows through these intermediate variables:
    
           43┆ async function                  
               getTemplateDirs(activePlugins) {
    
           44┆ const pluginTemplates =    
               activePlugins.map((id) => {
    
    
                This is how taint reaches the sink:
    
           51┆ return path.join(paths.nodeModules, id,
               plugins.pluginsData[id].templates ||   
               'templates');                          
    
    
            ⋮┆----------------------------------------
          123┆ await mkdirp(path.join(viewsPath,
               path.dirname(name)));            
    
    
          Taint comes from:
    
          115┆ files = await getTemplateDirs(files);
    
          Taint flows through these intermediate variables:
    
           43┆ async function                  
               getTemplateDirs(activePlugins) {
    
           44┆ const pluginTemplates =    
               activePlugins.map((id) => {
    
           71┆ let templateDirs = _.uniq([coreTemplates
               Path].concat(themeTemplates,            
               pluginTemplates));                      
    
           71┆ let templateDirs = _.uniq([coreTemplates
               Path].concat(themeTemplates,            
               pluginTemplates));                      
    
          then reaches:
    
           43┆ async function                  
               getTemplateDirs(activePlugins) {
    
    
          Taint flows through these intermediate variables:
    
          115┆ files = await getTemplateDirs(files);
    
          115┆ files = await getTemplateDirs(files);
    
          118┆ await                                   
               Promise.all(Object.keys(files).map(async
               (name) => {                             
    
    
                This is how taint reaches the sink:
    
          123┆ await mkdirp(path.join(viewsPath,
               path.dirname(name)));            
    
    
            ⋮┆----------------------------------------
          130┆ await                                   
               fs.promises.writeFile(path.join(viewsPat
               h, name), imported);                    
    
    
          Taint comes from:
    
          115┆ files = await getTemplateDirs(files);
    
          Taint flows through these intermediate variables:
    
           43┆ async function                  
               getTemplateDirs(activePlugins) {
    
           44┆ const pluginTemplates =    
               activePlugins.map((id) => {
    
           71┆ let templateDirs = _.uniq([coreTemplates
               Path].concat(themeTemplates,            
               pluginTemplates));                      
    
           71┆ let templateDirs = _.uniq([coreTemplates
               Path].concat(themeTemplates,            
               pluginTemplates));                      
    
          then reaches:
    
           43┆ async function                  
               getTemplateDirs(activePlugins) {
    
    
          Taint flows through these intermediate variables:
    
          115┆ files = await getTemplateDirs(files);
    
          115┆ files = await getTemplateDirs(files);
    
          118┆ await                                   
               Promise.all(Object.keys(files).map(async
               (name) => {                             
    
    
                This is how taint reaches the sink:
    
          130┆ await                                   
               fs.promises.writeFile(path.join(viewsPat
               h, name), imported);                    
    
                                     
  [36m[22m[24m  src/meta/themes.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           27┆ const config = path.join(themePath,
               theme, 'theme.json');              
    
    
          Taint comes from:
    
           26┆ themes = await                         
               Promise.all(themes.map(async (theme) =>
               {                                      
    
    
          Taint flows through these intermediate variables:
    
           26┆ themes = await                         
               Promise.all(themes.map(async (theme) =>
               {                                      
    
    
                This is how taint reaches the sink:
    
           27┆ const config = path.join(themePath,
               theme, 'theme.json');              
    
    
            ⋮┆----------------------------------------
           28┆ const pack = path.join(themePath, theme,
               'package.json');                        
    
    
          Taint comes from:
    
           26┆ themes = await                         
               Promise.all(themes.map(async (theme) =>
               {                                      
    
    
          Taint flows through these intermediate variables:
    
           26┆ themes = await                         
               Promise.all(themes.map(async (theme) =>
               {                                      
    
    
                This is how taint reaches the sink:
    
           28┆ const pack = path.join(themePath, theme,
               'package.json');                        
    
    
            ⋮┆----------------------------------------
           66┆ const dirpath = path.join(themePath,
               dir);                               
    
    
          Taint comes from:
    
           61┆ async function getThemes(themePath) {
    
    
          Taint flows through these intermediate variables:
    
           61┆ async function getThemes(themePath) {
    
    
                This is how taint reaches the sink:
    
           66┆ const dirpath = path.join(themePath,
               dir);                               
    
    
            ⋮┆----------------------------------------
           66┆ const dirpath = path.join(themePath,
               dir);                               
    
    
          Taint comes from:
    
           61┆ async function getThemes(themePath) {
    
    
          Taint flows through these intermediate variables:
    
           61┆ async function getThemes(themePath) {
    
           62┆ let dirs = await               
               fs.promises.readdir(themePath);
    
           62┆ let dirs = await               
               fs.promises.readdir(themePath);
    
           64┆ return await Promise.all(dirs.map(async
               (dir) => {                             
    
    
                This is how taint reaches the sink:
    
           66┆ const dirpath = path.join(themePath,
               dir);                               
    
    
            ⋮┆----------------------------------------
           76┆ const themes = await                 
               getThemes(path.join(themePath, dir));
    
    
          Taint comes from:
    
           61┆ async function getThemes(themePath) {
    
    
          Taint flows through these intermediate variables:
    
           61┆ async function getThemes(themePath) {
    
    
                This is how taint reaches the sink:
    
           76┆ const themes = await                 
               getThemes(path.join(themePath, dir));
    
    
            ⋮┆----------------------------------------
           76┆ const themes = await                 
               getThemes(path.join(themePath, dir));
    
    
          Taint comes from:
    
           61┆ async function getThemes(themePath) {
    
    
          Taint flows through these intermediate variables:
    
           61┆ async function getThemes(themePath) {
    
           62┆ let dirs = await               
               fs.promises.readdir(themePath);
    
           62┆ let dirs = await               
               fs.promises.readdir(themePath);
    
           64┆ return await Promise.all(dirs.map(async
               (dir) => {                             
    
    
                This is how taint reaches the sink:
    
           76┆ const themes = await                 
               getThemes(path.join(themePath, dir));
    
    
            ⋮┆----------------------------------------
           77┆ return themes.map(theme =>
               path.join(dir, theme));   
    
    
          Taint comes from:
    
           61┆ async function getThemes(themePath) {
    
    
          Taint flows through these intermediate variables:
    
           61┆ async function getThemes(themePath) {
    
           62┆ let dirs = await               
               fs.promises.readdir(themePath);
    
           62┆ let dirs = await               
               fs.promises.readdir(themePath);
    
           64┆ return await Promise.all(dirs.map(async
               (dir) => {                             
    
    
                This is how taint reaches the sink:
    
           77┆ return themes.map(theme =>
               path.join(dir, theme));   
    
    
            ⋮┆----------------------------------------
           77┆ return themes.map(theme =>
               path.join(dir, theme));   
    
    
          Taint comes from:
    
           61┆ async function getThemes(themePath) {
    
    
          Taint flows through these intermediate variables:
    
           61┆ async function getThemes(themePath) {
    
           76┆ const themes = await                 
               getThemes(path.join(themePath, dir));
    
           76┆ const themes = await                 
               getThemes(path.join(themePath, dir));
    
           77┆ return themes.map(theme =>
               path.join(dir, theme));   
    
    
                This is how taint reaches the sink:
    
           77┆ return themes.map(theme =>
               path.join(dir, theme));   
    
    
            ⋮┆----------------------------------------
           97┆ const pathToThemeJson =            
               path.join(nconf.get('themes_path'),
               data.id, 'theme.json');            
    
    
          Taint comes from:
    
           88┆ Themes.set = async (data) => {
    
    
          Taint flows through these intermediate variables:
    
           88┆ Themes.set = async (data) => {
    
    
                This is how taint reaches the sink:
    
           97┆ const pathToThemeJson =            
               path.join(nconf.get('themes_path'),
               data.id, 'theme.json');            
    
    
            ⋮┆----------------------------------------
          171┆ const fallback =                   
               path.join(nconf.get('themes_path'),
               themeObj.id, 'templates');         
    
    
          Taint comes from:
    
          168┆ Themes.setPath = function (themeObj) {
    
    
          Taint flows through these intermediate variables:
    
          168┆ Themes.setPath = function (themeObj) {
    
    
                This is how taint reaches the sink:
    
          171┆ const fallback =                   
               path.join(nconf.get('themes_path'),
               themeObj.id, 'templates');         
    
    
            ⋮┆----------------------------------------
          174┆ themePath =                        
               path.join(nconf.get('themes_path'),
               themeObj.id, themeObj.templates);  
    
    
          Taint comes from:
    
          168┆ Themes.setPath = function (themeObj) {
    
    
          Taint flows through these intermediate variables:
    
          168┆ Themes.setPath = function (themeObj) {
    
    
                This is how taint reaches the sink:
    
          174┆ themePath =                        
               path.join(nconf.get('themes_path'),
               themeObj.id, themeObj.templates);  
    
    
            ⋮┆----------------------------------------
          174┆ themePath =                        
               path.join(nconf.get('themes_path'),
               themeObj.id, themeObj.templates);  
    
    
          Taint comes from:
    
          168┆ Themes.setPath = function (themeObj) {
    
    
          Taint flows through these intermediate variables:
    
          168┆ Themes.setPath = function (themeObj) {
    
    
                This is how taint reaches the sink:
    
          174┆ themePath =                        
               path.join(nconf.get('themes_path'),
               themeObj.id, themeObj.templates);  
    
    
            ⋮┆----------------------------------------
          183┆ nconf.set('theme_config',          
               path.join(nconf.get('themes_path'),
               themeObj.id, 'theme.json'));       
    
    
          Taint comes from:
    
          168┆ Themes.setPath = function (themeObj) {
    
    
          Taint flows through these intermediate variables:
    
          168┆ Themes.setPath = function (themeObj) {
    
          174┆ themePath =                        
               path.join(nconf.get('themes_path'),
               themeObj.id, themeObj.templates);  
    
          182┆ nconf.set('theme_templates_path',
               themePath);                      
    
    
                This is how taint reaches the sink:
    
          183┆ nconf.set('theme_config',          
               path.join(nconf.get('themes_path'),
               themeObj.id, 'theme.json'));       
    
    
            ⋮┆----------------------------------------
          183┆ nconf.set('theme_config',          
               path.join(nconf.get('themes_path'),
               themeObj.id, 'theme.json'));       
    
    
          Taint comes from:
    
          168┆ Themes.setPath = function (themeObj) {
    
    
          Taint flows through these intermediate variables:
    
          168┆ Themes.setPath = function (themeObj) {
    
    
                This is how taint reaches the sink:
    
          183┆ nconf.set('theme_config',          
               path.join(nconf.get('themes_path'),
               themeObj.id, 'theme.json'));       
    
                                           
  [36m[22m[24m  src/middleware/assert.js[0m
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
           95┆ const pathToFile =                 
               path.join(nconf.get('upload_path'),
               req.body.path);                    
    
    
          Taint comes from:
    
           87┆ req.body.path = new         
               URL(req.body.path).pathname;
    
    
          Taint flows through these intermediate variables:
    
           87┆ req.body.path = new         
               URL(req.body.path).pathname;
    
           87┆ req.body.path = new         
               URL(req.body.path).pathname;
    
    
                This is how taint reaches the sink:
    
           95┆ const pathToFile =                 
               path.join(nconf.get('upload_path'),
               req.body.path);                    
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           95┆ const pathToFile =                 
               path.join(nconf.get('upload_path'),
               req.body.path);                    
    
    
          Taint comes from:
    
           84┆ Assert.path = helpers.try(async (req,
               res, next) => {                      
    
    
          Taint flows through these intermediate variables:
    
           84┆ Assert.path = helpers.try(async (req,
               res, next) => {                      
    
           87┆ req.body.path = new         
               URL(req.body.path).pathname;
    
           87┆ req.body.path = new         
               URL(req.body.path).pathname;
    
    
                This is how taint reaches the sink:
    
           95┆ const pathToFile =                 
               path.join(nconf.get('upload_path'),
               req.body.path);                    
    
    
            ⋮┆----------------------------------------
          112┆ const folderPath =               
               path.join(res.locals.cleanedPath,
               folderName);                     
    
    
          Taint comes from:
    
          110┆ Assert.folderName = helpers.try(async
               (req, res, next) => {                
    
    
          Taint flows through these intermediate variables:
    
          110┆ Assert.folderName = helpers.try(async
               (req, res, next) => {                
    
    
                This is how taint reaches the sink:
    
          112┆ const folderPath =               
               path.join(res.locals.cleanedPath,
               folderName);                     
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.express.security.audit.express-path-join-resolve-[0m
  [1m     traversal.express-path-join-resolve-traversal[0m               
          Possible writing outside of the destination, make
          sure that the target path is nested in the       
          intended destination                             
          Details: https://sg.run/weRn                     
                                                           
          112┆ const folderPath =               
               path.join(res.locals.cleanedPath,
               folderName);                     
    
    
          Taint comes from:
    
          111┆ const folderName = slugify(path.basename
               (req.body.folderName.trim()));          
    
    
          Taint flows through these intermediate variables:
    
          111┆ const folderName = slugify(path.basename
               (req.body.folderName.trim()));          
    
    
                This is how taint reaches the sink:
    
          112┆ const folderPath =               
               path.join(res.locals.cleanedPath,
               folderName);                     
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          112┆ const folderPath =               
               path.join(res.locals.cleanedPath,
               folderName);                     
    
    
          Taint comes from:
    
          110┆ Assert.folderName = helpers.try(async
               (req, res, next) => {                
    
    
          Taint flows through these intermediate variables:
    
          110┆ Assert.folderName = helpers.try(async
               (req, res, next) => {                
    
          111┆ const folderName = slugify(path.basename
               (req.body.folderName.trim()));          
    
    
                This is how taint reaches the sink:
    
          112┆ const folderPath =               
               path.join(res.locals.cleanedPath,
               folderName);                     
    
                                            
  [36m[22m[24m  src/middleware/headers.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `origin` function         
          argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS)     
          within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use
          hardcoded regexes instead. If your regex is run  
          on user-controlled input, consider performing    
          input validation or use a regex                  
          checking/sanitization library such as            
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
           44┆ origin = new RegExp(origin.trim());
    
    
          Taint comes from:
    
           42┆ originsRegex = originsRegex.map((origin)
               => {                                    
    
    
          Taint flows through these intermediate variables:
    
           42┆ originsRegex = originsRegex.map((origin)
               => {                                    
    
    
                This is how taint reaches the sink:
    
           44┆ origin = new RegExp(origin.trim());
    
                                          
  [36m[22m[24m  src/middleware/index.js[0m
    ❯❱ [1mjavascript.express.web.tainted-redirect-express.tainted-[0m
  [1m     redirect-express[0m                                        
          The application builds a URL using user-         
          controlled input which can lead to an open       
          redirect vulnerability. An attacker can          
          manipulate the URL and redirect users to an      
          arbitrary domain. Open redirect vulnerabilities  
          can lead to issues such as Cross-site scripting  
          (XSS) or redirecting to a malicious domain for   
          activities such as phishing to capture users'    
          credentials. To prevent this vulnerability       
          perform strict input validation of the domain    
          against an allowlist of approved domains. Notify 
          a user in your application that they are leaving 
          the website. Display a domain where they are     
          redirected to the user. A user can then either   
          accept or deny the redirect to an untrusted site.
          Details: https://sg.run/7KEAw                    
                                                           
           75┆ return res.redirect(relative_path +
               target.replace(/^\/+/, '/'));      
    
    
          Taint comes from:
    
           73┆ const target =                        
               req.originalUrl.replace(relative_path,
               '');                                  
    
    
          Taint flows through these intermediate variables:
    
           73┆ const target =                        
               req.originalUrl.replace(relative_path,
               '');                                  
    
    
                This is how taint reaches the sink:
    
           75┆ return res.redirect(relative_path +
               target.replace(/^\/+/, '/'));      
    
                                         
  [36m[22m[24m  src/middleware/user.js[0m
    ❯❱ [1mjavascript.express.web.tainted-redirect-express.tainted-[0m
  [1m     redirect-express[0m                                        
          The application builds a URL using user-         
          controlled input which can lead to an open       
          redirect vulnerability. An attacker can          
          manipulate the URL and redirect users to an      
          arbitrary domain. Open redirect vulnerabilities  
          can lead to issues such as Cross-site scripting  
          (XSS) or redirecting to a malicious domain for   
          activities such as phishing to capture users'    
          credentials. To prevent this vulnerability       
          perform strict input validation of the domain    
          against an allowlist of approved domains. Notify 
          a user in your application that they are leaving 
          the website. Display a domain where they are     
          redirected to the user. A user can then either   
          accept or deny the redirect to an untrusted site.
          Details: https://sg.run/7KEAw                    
                                                           
          259┆ return res.redirect(`${nconf.get('relati
               ve_path')}${newPath}`);                 
    
    
          Taint comes from:
    
          258┆ const newPath =                         
               req.path.replace(`/${req.params.userslug
               }`, () => `/${lowercaseSlug}`);         
    
    
          Taint flows through these intermediate variables:
    
          258┆ const newPath =                         
               req.path.replace(`/${req.params.userslug
               }`, () => `/${lowercaseSlug}`);         
    
          258┆ const newPath =                         
               req.path.replace(`/${req.params.userslug
               }`, () => `/${lowercaseSlug}`);         
    
    
                This is how taint reaches the sink:
    
          259┆ return res.redirect(`${nconf.get('relati
               ve_path')}${newPath}`);                 
    
                                      
  [36m[22m[24m  src/plugins/data.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           29┆ .map(plugin =>                        
               path.join(paths.nodeModules, plugin));
    
    
          Taint comes from:
    
           29┆ .map(plugin =>                        
               path.join(paths.nodeModules, plugin));
    
    
          Taint flows through these intermediate variables:
    
           29┆ .map(plugin =>                        
               path.join(paths.nodeModules, plugin));
    
    
                This is how taint reaches the sink:
    
           29┆ .map(plugin =>                        
               path.join(paths.nodeModules, plugin));
    
    
            ⋮┆----------------------------------------
           41┆                                         
               fs.promises.readFile(path.join(pluginPat
               h, 'package.json'), 'utf8'),            
    
    
          Taint comes from:
    
           39┆ Data.loadPluginInfo = async function
               (pluginPath) {                      
    
    
          Taint flows through these intermediate variables:
    
           39┆ Data.loadPluginInfo = async function
               (pluginPath) {                      
    
    
                This is how taint reaches the sink:
    
           41┆                                         
               fs.promises.readFile(path.join(pluginPat
               h, 'package.json'), 'utf8'),            
    
    
            ⋮┆----------------------------------------
           42┆                                         
               fs.promises.readFile(path.join(pluginPat
               h, 'plugin.json'), 'utf8'),             
    
    
          Taint comes from:
    
           39┆ Data.loadPluginInfo = async function
               (pluginPath) {                      
    
    
          Taint flows through these intermediate variables:
    
           39┆ Data.loadPluginInfo = async function
               (pluginPath) {                      
    
    
                This is how taint reaches the sink:
    
           42┆                                         
               fs.promises.readFile(path.join(pluginPat
               h, 'plugin.json'), 'utf8'),             
    
    
            ⋮┆----------------------------------------
          146┆ return pluginData[type].map(file =>
               path.join(pluginData.id, file));   
    
    
          Taint comes from:
    
          139┆ Data.getFiles = async function
               (pluginData, type) {          
    
    
          Taint flows through these intermediate variables:
    
          139┆ Data.getFiles = async function
               (pluginData, type) {          
    
    
                This is how taint reaches the sink:
    
          146┆ return pluginData[type].map(file =>
               path.join(pluginData.id, file));   
    
    
            ⋮┆----------------------------------------
          146┆ return pluginData[type].map(file =>
               path.join(pluginData.id, file));   
    
    
          Taint comes from:
    
          139┆ Data.getFiles = async function
               (pluginData, type) {          
    
    
          Taint flows through these intermediate variables:
    
          139┆ Data.getFiles = async function
               (pluginData, type) {          
    
          146┆ return pluginData[type].map(file =>
               path.join(pluginData.id, file));   
    
    
                This is how taint reaches the sink:
    
          146┆ return pluginData[type].map(file =>
               path.join(pluginData.id, file));   
    
    
            ⋮┆----------------------------------------
          156┆ const currentPath = path.join(basePath,
               modulePath);                           
    
    
          Taint comes from:
    
          153┆ async function                         
               resolveModulePath(basePath, modulePath)
               {                                      
    
    
          Taint flows through these intermediate variables:
    
          153┆ async function                         
               resolveModulePath(basePath, modulePath)
               {                                      
    
    
                This is how taint reaches the sink:
    
          156┆ const currentPath = path.join(basePath,
               modulePath);                           
    
    
            ⋮┆----------------------------------------
          156┆ const currentPath = path.join(basePath,
               modulePath);                           
    
    
          Taint comes from:
    
          102┆ async function processDir(route) {
    
    
          Taint flows through these intermediate variables:
    
          102┆ async function processDir(route) {
    
    
                This is how taint reaches the sink:
    
          108┆ const dirPath = await             
               resolveModulePath(pluginData.path,
               pluginData.staticDirs[route]);    
    
          Taint flows through these intermediate variables:
    
          153┆ async function                         
               resolveModulePath(basePath, modulePath)
               {                                      
    
          then reaches:
    
          156┆ const currentPath = path.join(basePath,
               modulePath);                           
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `pluginData` function     
          argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS)     
          within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use
          hardcoded regexes instead. If your regex is run  
          on user-controlled input, consider performing    
          input validation or use a regex                  
          checking/sanitization library such as            
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          213┆ key = modulePath.replace(new         
               RegExp(`.?(/[^/]+){${strip}}/`), '');
    
    
          Taint comes from:
    
          200┆ Data.getModules = async function
               getModules(pluginData) {        
    
    
          Taint flows through these intermediate variables:
    
          200┆ Data.getModules = async function
               getModules(pluginData) {        
    
          208┆ const strip =                           
               parseInt(pluginData.modulesStrip, 10) ||
               0;                                      
    
          213┆ key = modulePath.replace(new         
               RegExp(`.?(/[^/]+){${strip}}/`), '');
    
    
                This is how taint reaches the sink:
    
          213┆ key = modulePath.replace(new         
               RegExp(`.?(/[^/]+){${strip}}/`), '');
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          243┆ const pathToFolder =                 
               path.join(paths.nodeModules,         
               pluginData.id, pluginData.languages);
    
    
          Taint comes from:
    
          238┆ Data.getLanguageData = async function
               getLanguageData(pluginData) {        
    
    
          Taint flows through these intermediate variables:
    
          238┆ Data.getLanguageData = async function
               getLanguageData(pluginData) {        
    
    
                This is how taint reaches the sink:
    
          243┆ const pathToFolder =                 
               path.join(paths.nodeModules,         
               pluginData.id, pluginData.languages);
    
    
            ⋮┆----------------------------------------
          243┆ const pathToFolder =                 
               path.join(paths.nodeModules,         
               pluginData.id, pluginData.languages);
    
    
          Taint comes from:
    
          238┆ Data.getLanguageData = async function
               getLanguageData(pluginData) {        
    
    
          Taint flows through these intermediate variables:
    
          238┆ Data.getLanguageData = async function
               getLanguageData(pluginData) {        
    
    
                This is how taint reaches the sink:
    
          243┆ const pathToFolder =                 
               path.join(paths.nodeModules,         
               pluginData.id, pluginData.languages);
    
                                       
  [36m[22m[24m  src/plugins/index.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          273┆ pluginPaths = pluginPaths.map(dir =>
               path.join(Plugins.nodeModulesPath,  
               dir));                              
    
    
          Taint comes from:
    
          273┆ pluginPaths = pluginPaths.map(dir =>
               path.join(Plugins.nodeModulesPath,  
               dir));                              
    
    
          Taint flows through these intermediate variables:
    
          273┆ pluginPaths = pluginPaths.map(dir =>
               path.join(Plugins.nodeModulesPath,  
               dir));                              
    
    
                This is how taint reaches the sink:
    
          273┆ pluginPaths = pluginPaths.map(dir =>
               path.join(Plugins.nodeModulesPath,  
               dir));                              
    
    
            ⋮┆----------------------------------------
          296┆ const dirPath =                   
               path.join(Plugins.nodeModulesPath,
               dirname);                         
    
    
          Taint comes from:
    
          293┆ async function findNodeBBModules(dirs) {
    
    
          Taint flows through these intermediate variables:
    
          293┆ async function findNodeBBModules(dirs) {
    
          295┆ await Promise.all(dirs.map(async
               (dirname) => {                  
    
    
                This is how taint reaches the sink:
    
          296┆ const dirPath =                   
               path.join(Plugins.nodeModulesPath,
               dirname);                         
    
    
            ⋮┆----------------------------------------
          313┆ const subdirPath = path.join(dirPath,
               subdir);                             
    
    
          Taint comes from:
    
          293┆ async function findNodeBBModules(dirs) {
    
    
          Taint flows through these intermediate variables:
    
          293┆ async function findNodeBBModules(dirs) {
    
          295┆ await Promise.all(dirs.map(async
               (dirname) => {                  
    
    
                This is how taint reaches the sink:
    
          313┆ const subdirPath = path.join(dirPath,
               subdir);                             
    
    
            ⋮┆----------------------------------------
          313┆ const subdirPath = path.join(dirPath,
               subdir);                             
    
    
          Taint comes from:
    
          293┆ async function findNodeBBModules(dirs) {
    
    
          Taint flows through these intermediate variables:
    
          293┆ async function findNodeBBModules(dirs) {
    
          295┆ await Promise.all(dirs.map(async
               (dirname) => {                  
    
    
                This is how taint reaches the sink:
    
          313┆ const subdirPath = path.join(dirPath,
               subdir);                             
    
                                         
  [36m[22m[24m  src/plugins/install.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          150┆ const pluginDir =                
               path.join(paths.nodeModules, id);
    
    
          Taint comes from:
    
          149┆ Plugins.isInstalled = async function
               (id) {                              
    
    
          Taint flows through these intermediate variables:
    
          149┆ Plugins.isInstalled = async function
               (id) {                              
    
    
                This is how taint reaches the sink:
    
          150┆ const pluginDir =                
               path.join(paths.nodeModules, id);
    
    
            ⋮┆----------------------------------------
          160┆ const pluginDir =               
               path.join(paths.nodeModules, id,
               'plugin.json');                 
    
    
          Taint comes from:
    
          159┆ Plugins.isSystemPlugin = async function
               (id) {                                 
    
    
          Taint flows through these intermediate variables:
    
          159┆ Plugins.isSystemPlugin = async function
               (id) {                                 
    
    
                This is how taint reaches the sink:
    
          160┆ const pluginDir =               
               path.join(paths.nodeModules, id,
               'plugin.json');                 
    
                                      
  [36m[22m[24m  src/posts/create.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `data` function argument, 
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
           64┆ postData.content =                      
               postData.content.replace(new            
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
          Taint comes from:
    
           15┆ Posts.create = async function (data) {
    
    
          Taint flows through these intermediate variables:
    
           15┆ Posts.create = async function (data) {
    
           17┆ const { uid, tid, _activitypub,
               sourceContent } = data;        
    
           56┆ .forEach((tag) => {
    
           58┆ tag.name = `:${tag.name}`;
    
           58┆ tag.name = `:${tag.name}`;
    
    
                This is how taint reaches the sink:
    
           64┆ postData.content =                      
               postData.content.replace(new            
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `tag` function argument,  
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
           64┆ postData.content =                      
               postData.content.replace(new            
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
    
          Taint comes from:
    
           56┆ .forEach((tag) => {
    
    
          Taint flows through these intermediate variables:
    
           56┆ .forEach((tag) => {
    
           58┆ tag.name = `:${tag.name}`;
    
           58┆ tag.name = `:${tag.name}`;
    
    
                This is how taint reaches the sink:
    
           64┆ postData.content =                      
               postData.content.replace(new            
               RegExp(tag.name, 'g'), `<img class="not-
               responsive emoji" src="${tag.icon.url}" 
               title="${tag.name}" />`);               
    
                                       
  [36m[22m[24m  src/posts/uploads.js[0m
    ❯❱ [1mjavascript.node-stdlib.cryptography.crypto-weak-[0m
  [1m     algorithm.crypto-weak-algorithm[0m                 
          The use of a weak cryptographic algorithm (e.g., 
          SHA-1 or MD5) has been identified. These         
          algorithms are considered insecure due to        
          vulnerabilities that make them susceptible to    
          collision attacks, allowing attackers to         
          compromise data integrity or security. Replace   
          SHA-1 or MD5 with secure hashing algorithms, such
          as: SHA-256 or higher (e.g., SHA-3).             
          Details: https://sg.run/nJgp1                    
                                                           
           23┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
          Taint comes from:
    
           23┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
                This is how taint reaches the sink:
    
           23┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           27┆ const _getFullPath = relativePath =>
               path.join(pathPrefix, relativePath);
    
    
          Taint comes from:
    
           27┆ const _getFullPath = relativePath =>
               path.join(pathPrefix, relativePath);
    
    
          Taint flows through these intermediate variables:
    
           27┆ const _getFullPath = relativePath =>
               path.join(pathPrefix, relativePath);
    
    
                This is how taint reaches the sink:
    
           27┆ const _getFullPath = relativePath =>
               path.join(pathPrefix, relativePath);
    
                                  
  [36m[22m[24m  src/prestart.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           81┆ nconf.set('themes_path',   
               path.resolve(paths.baseDir,
               nconf.get('themes_path')));
    
    
          Taint comes from:
    
           71┆ castAsBool.forEach((prop) => {
    
    
          Taint flows through these intermediate variables:
    
           71┆ castAsBool.forEach((prop) => {
    
           72┆ const value = nconf.get(prop);
    
           74┆ nconf.set(prop, ['1', 1, 'true',
               true].includes(value));         
    
           74┆ nconf.set(prop, ['1', 1, 'true',
               true].includes(value));         
    
    
                This is how taint reaches the sink:
    
           81┆ nconf.set('themes_path',   
               path.resolve(paths.baseDir,
               nconf.get('themes_path')));
    
    
            ⋮┆----------------------------------------
           84┆ nconf.set('upload_path',           
               path.resolve(nconf.get('base_dir'),
               nconf.get('upload_path')));        
    
    
          Taint comes from:
    
           71┆ castAsBool.forEach((prop) => {
    
    
          Taint flows through these intermediate variables:
    
           71┆ castAsBool.forEach((prop) => {
    
           72┆ const value = nconf.get(prop);
    
           74┆ nconf.set(prop, ['1', 1, 'true',
               true].includes(value));         
    
           74┆ nconf.set(prop, ['1', 1, 'true',
               true].includes(value));         
    
    
                This is how taint reaches the sink:
    
           84┆ nconf.set('upload_path',           
               path.resolve(nconf.get('base_dir'),
               nconf.get('upload_path')));        
    
    
            ⋮┆----------------------------------------
           84┆ nconf.set('upload_path',           
               path.resolve(nconf.get('base_dir'),
               nconf.get('upload_path')));        
    
    
          Taint comes from:
    
           71┆ castAsBool.forEach((prop) => {
    
    
          Taint flows through these intermediate variables:
    
           71┆ castAsBool.forEach((prop) => {
    
           72┆ const value = nconf.get(prop);
    
           74┆ nconf.set(prop, ['1', 1, 'true',
               true].includes(value));         
    
           74┆ nconf.set(prop, ['1', 1, 'true',
               true].includes(value));         
    
    
                This is how taint reaches the sink:
    
           84┆ nconf.set('upload_path',           
               path.resolve(nconf.get('base_dir'),
               nconf.get('upload_path')));        
    
                                      
  [36m[22m[24m  src/routes/index.js[0m
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `mount` function argument,
          this might allow an attacker to cause a Regular  
          Expression Denial-of-Service (ReDoS) within your 
          application as RegExP blocks the main thread. For
          this reason, it is recommended to use hardcoded  
          regexes instead. If your regex is run on user-   
          controlled input, consider performing input      
          validation or use a regex checking/sanitization  
          library such as                                  
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          219┆ router.use(new                      
               RegExp(`/(api/)?${original}`), (req,
               res) => {                           
    
    
          Taint comes from:
    
          121┆ Object.keys(mounts).forEach((mount) => {
    
    
          Taint flows through these intermediate variables:
    
          121┆ Object.keys(mounts).forEach((mount) => {
    
          125┆ mounts[mount] = mount;
    
          125┆ mounts[mount] = mount;
    
    
                This is how taint reaches the sink:
    
          149┆ addCoreRoutes(app, router, middleware,
               mounts);                              
    
          Taint flows through these intermediate variables:
    
          154┆ function addCoreRoutes(app, router,
               middleware, mounts) {              
    
          then call to:
    
          165┆ addRemountableRoutes(app, router,
               middleware, mounts);             
    
          Taint flows through these intermediate variables:
    
          206┆ function addRemountableRoutes(app,
               router, middleware, mounts) {     
    
          207┆ Object.keys(mounts).map(async (mount) =>
               {                                       
    
          208┆ const original = mount;
    
          219┆ router.use(new                      
               RegExp(`/(api/)?${original}`), (req,
               res) => {                           
    
          then reaches:
    
          219┆ router.use(new                      
               RegExp(`/(api/)?${original}`), (req,
               res) => {                           
    
    
            ⋮┆----------------------------------------
    ❯❱ [1mjavascript.lang.security.audit.detect-non-literal-[0m
  [1m     regexp.detect-non-literal-regexp[0m                  
          RegExp() called with a `mounts` function         
          argument, this might allow an attacker to cause a
          Regular Expression Denial-of-Service (ReDoS)     
          within your application as RegExP blocks the main
          thread. For this reason, it is recommended to use
          hardcoded regexes instead. If your regex is run  
          on user-controlled input, consider performing    
          input validation or use a regex                  
          checking/sanitization library such as            
          https://www.npmjs.com/package/recheck to verify  
          that the regex does not appear vulnerable to     
          ReDoS.                                           
          Details: https://sg.run/gr65                     
                                                           
          219┆ router.use(new                      
               RegExp(`/(api/)?${original}`), (req,
               res) => {                           
    
    
          Taint comes from:
    
          154┆ function addCoreRoutes(app, router,
               middleware, mounts) {              
    
    
          Taint flows through these intermediate variables:
    
          154┆ function addCoreRoutes(app, router,
               middleware, mounts) {              
    
    
                This is how taint reaches the sink:
    
          165┆ addRemountableRoutes(app, router,
               middleware, mounts);             
    
          Taint flows through these intermediate variables:
    
          206┆ function addRemountableRoutes(app,
               router, middleware, mounts) {     
    
          207┆ Object.keys(mounts).map(async (mount) =>
               {                                       
    
          208┆ const original = mount;
    
          219┆ router.use(new                      
               RegExp(`/(api/)?${original}`), (req,
               res) => {                           
    
          then reaches:
    
          219┆ router.use(new                      
               RegExp(`/(api/)?${original}`), (req,
               res) => {                           
    
                                  
  [36m[22m[24m  src/settings.js[0m
    ❯❱ [1mjavascript.lang.security.audit.prototype-[0m              
  [1m     pollution.prototype-pollution-loop.prototype-pollution-[0m
  [1m     loop[0m                                                   
          Possibility of prototype polluting function      
          detected. By adding or modifying attributes of an
          object prototype, it is possible to create       
          attributes that exist on every object, or replace
          critical attributes with malicious ones. This can
          be problematic if the software depends on        
          existence or non-existence of certain attributes,
          or uses pre-defined attributes of object         
          prototype (such as hasOwnProperty, toString or   
          valueOf). Possible mitigations might be: freezing
          the object prototype, using an object without    
          prototypes (via Object.create(null) ), blocking  
          modifications of attributes that resolve to      
          object prototype, using Map instead of object.   
          Details: https://sg.run/w1DB                     
                                                           
          139┆ obj = obj[part];
            ⋮┆----------------------------------------
          148┆ def = def[part];
            ⋮┆----------------------------------------
          205┆ obj = obj[part];
                                       
  [36m[22m[24m  src/topics/thumbs.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          176┆ const absolutePaths =              
               relativePaths.map(relativePath =>  
               path.join(nconf.get('upload_path'),
               relativePath));                    
    
    
          Taint comes from:
    
          166┆ Thumbs.delete = async function (id,
               relativePaths) {                   
    
    
          Taint flows through these intermediate variables:
    
          166┆ Thumbs.delete = async function (id,
               relativePaths) {                   
    
          176┆ const absolutePaths =              
               relativePaths.map(relativePath =>  
               path.join(nconf.get('upload_path'),
               relativePath));                    
    
    
                This is how taint reaches the sink:
    
          176┆ const absolutePaths =              
               relativePaths.map(relativePath =>  
               path.join(nconf.get('upload_path'),
               relativePath));                    
    
                                 
  [36m[22m[24m  src/upgrade.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           66┆ const configPath =                  
               path.join(paths.nodeModules, plugin,
               'plugin.json');                     
    
    
          Taint comes from:
    
           65┆ activePlugins.forEach((plugin) => {
    
    
          Taint flows through these intermediate variables:
    
           65┆ activePlugins.forEach((plugin) => {
    
    
                This is how taint reaches the sink:
    
           66┆ const configPath =                  
               path.join(paths.nodeModules, plugin,
               'plugin.json');                     
    
    
            ⋮┆----------------------------------------
           71┆ files.push(path.join(path.dirname(config
               Path), script));                        
    
    
          Taint comes from:
    
           65┆ activePlugins.forEach((plugin) => {
    
    
          Taint flows through these intermediate variables:
    
           65┆ activePlugins.forEach((plugin) => {
    
           66┆ const configPath =                  
               path.join(paths.nodeModules, plugin,
               'plugin.json');                     
    
    
                This is how taint reaches the sink:
    
           71┆ files.push(path.join(path.dirname(config
               Path), script));                        
    
    
            ⋮┆----------------------------------------
           71┆ files.push(path.join(path.dirname(config
               Path), script));                        
    
    
          Taint comes from:
    
           65┆ activePlugins.forEach((plugin) => {
    
    
          Taint flows through these intermediate variables:
    
           65┆ activePlugins.forEach((plugin) => {
    
           66┆ const configPath =                  
               path.join(paths.nodeModules, plugin,
               'plugin.json');                     
    
           68┆ const pluginConfig =
               require(configPath);
    
           68┆ const pluginConfig =
               require(configPath);
    
           70┆ pluginConfig.upgrades.forEach((script)
               => {                                  
    
    
                This is how taint reaches the sink:
    
           71┆ files.push(path.join(path.dirname(config
               Path), script));                        
    
                                                                  
  [36m[22m[24m  src/upgrades/1.10.0/hash_recent_ip_addresses.js[0m
    ❯❱ [1mjavascript.node-stdlib.cryptography.crypto-weak-[0m
  [1m     algorithm.crypto-weak-algorithm[0m                 
          The use of a weak cryptographic algorithm (e.g., 
          SHA-1 or MD5) has been identified. These         
          algorithms are considered insecure due to        
          vulnerabilities that make them susceptible to    
          collision attacks, allowing attackers to         
          compromise data integrity or security. Replace   
          SHA-1 or MD5 with secure hashing algorithms, such
          as: SHA-256 or higher (e.g., SHA-3).             
          Details: https://sg.run/nJgp1                    
                                                           
           26┆ hash =                                  
               crypto.createHash('sha1').update(set.val
               ue + nconf.get('secret')).digest('hex');
    
    
          Taint comes from:
    
           26┆ hash =                                  
               crypto.createHash('sha1').update(set.val
               ue + nconf.get('secret')).digest('hex');
    
    
                This is how taint reaches the sink:
    
           26┆ hash =                                  
               crypto.createHash('sha1').update(set.val
               ue + nconf.get('secret')).digest('hex');
    
                                                                     
  [36m[22m[24m                                                       
  src/upgrades/1.19.2/remove_leftover_thumbs_after_topic_purge.js[0m 
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           35┆ const absolutePaths =              
               relativePaths.map(relativePath =>  
               path.join(nconf.get('upload_path'),
               relativePath));                    
    
    
          Taint comes from:
    
           32┆ await batch.processArray(affectedTids,
               async (tids) => {                     
    
    
          Taint flows through these intermediate variables:
    
           32┆ await batch.processArray(affectedTids,
               async (tids) => {                     
    
           33┆ await Promise.all(tids.map(async (tid)
               => {                                  
    
    
                This is how taint reaches the sink:
    
           35┆ const absolutePaths =              
               relativePaths.map(relativePath =>  
               path.join(nconf.get('upload_path'),
               relativePath));                    
    
                                                               
  [36m[22m[24m  src/upgrades/1.19.3/fix_user_uploads_zset.js[0m
    ❯❱ [1mjavascript.node-stdlib.cryptography.crypto-weak-[0m
  [1m     algorithm.crypto-weak-algorithm[0m                 
          The use of a weak cryptographic algorithm (e.g., 
          SHA-1 or MD5) has been identified. These         
          algorithms are considered insecure due to        
          vulnerabilities that make them susceptible to    
          collision attacks, allowing attackers to         
          compromise data integrity or security. Replace   
          SHA-1 or MD5 with secure hashing algorithms, such
          as: SHA-256 or higher (e.g., SHA-3).             
          Details: https://sg.run/nJgp1                    
                                                           
            8┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
          Taint comes from:
    
            8┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
                This is how taint reaches the sink:
    
            8┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
                                                                   
  [36m[22m[24m  src/upgrades/1.19.3/rename_post_upload_hashes.js[0m
    ❯❱ [1mjavascript.node-stdlib.cryptography.crypto-weak-[0m
  [1m     algorithm.crypto-weak-algorithm[0m                 
          The use of a weak cryptographic algorithm (e.g., 
          SHA-1 or MD5) has been identified. These         
          algorithms are considered insecure due to        
          vulnerabilities that make them susceptible to    
          collision attacks, allowing attackers to         
          compromise data integrity or security. Replace   
          SHA-1 or MD5 with secure hashing algorithms, such
          as: SHA-256 or higher (e.g., SHA-3).             
          Details: https://sg.run/nJgp1                    
                                                           
           10┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
          Taint comes from:
    
           10┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
                This is how taint reaches the sink:
    
           10┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
                                                                    
  [36m[22m[24m  src/upgrades/1.6.0/clear-stale-digest-template.js[0m
    ❯❱ [1mjavascript.node-stdlib.cryptography.crypto-weak-[0m
  [1m     algorithm.crypto-weak-algorithm[0m                 
          The use of a weak cryptographic algorithm (e.g., 
          SHA-1 or MD5) has been identified. These         
          algorithms are considered insecure due to        
          vulnerabilities that make them susceptible to    
          collision attacks, allowing attackers to         
          compromise data integrity or security. Replace   
          SHA-1 or MD5 with secure hashing algorithms, such
          as: SHA-256 or higher (e.g., SHA-3).             
          Details: https://sg.run/nJgp1                    
                                                           
           16┆ const hash =                            
               fieldset['email:custom:digest'] ? crypto
               .createHash('md5').update(fieldset['emai
               l:custom:digest']).digest('hex') : null;
    
    
          Taint comes from:
    
           16┆ const hash =                            
               fieldset['email:custom:digest'] ? crypto
               .createHash('md5').update(fieldset['emai
               l:custom:digest']).digest('hex') : null;
    
    
                This is how taint reaches the sink:
    
           16┆ const hash =                            
               fieldset['email:custom:digest'] ? crypto
               .createHash('md5').update(fieldset['emai
               l:custom:digest']).digest('hex') : null;
    
                                                                
  [36m[22m[24m  src/upgrades/1.7.6/flatten_navigation_data.js[0m
    ❯❱ [1mjavascript.lang.security.audit.prototype-[0m              
  [1m     pollution.prototype-pollution-loop.prototype-pollution-[0m
  [1m     loop[0m                                                   
          Possibility of prototype polluting function      
          detected. By adding or modifying attributes of an
          object prototype, it is possible to create       
          attributes that exist on every object, or replace
          critical attributes with malicious ones. This can
          be problematic if the software depends on        
          existence or non-existence of certain attributes,
          or uses pre-defined attributes of object         
          prototype (such as hasOwnProperty, toString or   
          valueOf). Possible mitigations might be: freezing
          the object prototype, using an object without    
          prototypes (via Object.create(null) ), blocking  
          modifications of attributes that resolve to      
          object prototype, using Map instead of object.   
          Details: https://sg.run/w1DB                     
                                                           
           16┆ navItem = navItem[keys[0]];
                                                            
  [36m[22m[24m  src/upgrades/3.8.0/user-upload-folders.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           33┆ await mkdirp(path.join(folder,
               `uid-${uid}`));               
    
    
          Taint comes from:
    
           28┆ await batch.processArray(files, async
               (files) => {                         
    
    
          Taint flows through these intermediate variables:
    
           28┆ await batch.processArray(files, async
               (files) => {                         
    
           30┆ await Promise.all(files.map(async (file)
               => {                                    
    
    
                This is how taint reaches the sink:
    
           33┆ await mkdirp(path.join(folder,
               `uid-${uid}`));               
    
    
            ⋮┆----------------------------------------
           35┆ path.join(folder, file),
    
    
          Taint comes from:
    
           28┆ await batch.processArray(files, async
               (files) => {                         
    
    
          Taint flows through these intermediate variables:
    
           28┆ await batch.processArray(files, async
               (files) => {                         
    
           30┆ await Promise.all(files.map(async (file)
               => {                                    
    
    
                This is how taint reaches the sink:
    
           35┆ path.join(folder, file),
    
    
            ⋮┆----------------------------------------
           36┆ path.join(folder, `uid-${uid}`, file),
    
    
          Taint comes from:
    
           28┆ await batch.processArray(files, async
               (files) => {                         
    
    
          Taint flows through these intermediate variables:
    
           28┆ await batch.processArray(files, async
               (files) => {                         
    
           30┆ await Promise.all(files.map(async (file)
               => {                                    
    
    
                This is how taint reaches the sink:
    
           36┆ path.join(folder, `uid-${uid}`, file),
    
    
            ⋮┆----------------------------------------
           36┆ path.join(folder, `uid-${uid}`, file),
    
    
          Taint comes from:
    
           28┆ await batch.processArray(files, async
               (files) => {                         
    
    
          Taint flows through these intermediate variables:
    
           28┆ await batch.processArray(files, async
               (files) => {                         
    
           30┆ await Promise.all(files.map(async (file)
               => {                                    
    
    
                This is how taint reaches the sink:
    
           36┆ path.join(folder, `uid-${uid}`, file),
    
                                                                 
  [36m[22m[24m  src/upgrades/4.3.0/normalize_thumbs_uploads.js[0m
    ❯❱ [1mjavascript.node-stdlib.cryptography.crypto-weak-[0m
  [1m     algorithm.crypto-weak-algorithm[0m                 
          The use of a weak cryptographic algorithm (e.g., 
          SHA-1 or MD5) has been identified. These         
          algorithms are considered insecure due to        
          vulnerabilities that make them susceptible to    
          collision attacks, allowing attackers to         
          compromise data integrity or security. Replace   
          SHA-1 or MD5 with secure hashing algorithms, such
          as: SHA-256 or higher (e.g., SHA-3).             
          Details: https://sg.run/nJgp1                    
                                                           
           28┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
          Taint comes from:
    
           28┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
                This is how taint reaches the sink:
    
           28┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
                                     
  [36m[22m[24m  src/user/delete.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          240┆ const folder =                     
               path.join(nconf.get('upload_path'),
               'profile', `uid-${uid}`);          
    
    
          Taint comes from:
    
          238┆ async function deleteImages(uid) {
    
    
          Taint flows through these intermediate variables:
    
          238┆ async function deleteImages(uid) {
    
    
                This is how taint reaches the sink:
    
          240┆ const folder =                     
               path.join(nconf.get('upload_path'),
               'profile', `uid-${uid}`);          
    
                                                
  [36m[22m[24m  src/user/jobs/export-posts.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           30┆ const filePath = path.join(__dirname,
               '../../../build/export',             
               `${targetUid}_posts.csv`);           
    
    
          Taint comes from:
    
           25┆ process.on('message', async (msg) => {
    
    
          Taint flows through these intermediate variables:
    
           25┆ process.on('message', async (msg) => {
    
           29┆ const targetUid = msg.uid;
    
    
                This is how taint reaches the sink:
    
           30┆ const filePath = path.join(__dirname,
               '../../../build/export',             
               `${targetUid}_posts.csv`);           
    
                                                  
  [36m[22m[24m  src/user/jobs/export-profile.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           33┆ const profilePath = path.join(__dirname,
               '../../../build/export', profileFile);  
    
    
          Taint comes from:
    
           25┆ process.on('message', async (msg) => {
    
    
          Taint flows through these intermediate variables:
    
           25┆ process.on('message', async (msg) => {
    
           30┆ const targetUid = msg.uid;
    
           32┆ const profileFile =         
               `${targetUid}_profile.json`;
    
           32┆ const profileFile =         
               `${targetUid}_profile.json`;
    
    
                This is how taint reaches the sink:
    
           33┆ const profilePath = path.join(__dirname,
               '../../../build/export', profileFile);  
    
                                                  
  [36m[22m[24m  src/user/jobs/export-uploads.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           31┆ const archivePath = path.join(__dirname,
               '../../../build/export',                
               `${targetUid}_uploads.zip`);            
    
    
          Taint comes from:
    
           25┆ process.on('message', async (msg) => {
    
    
          Taint flows through these intermediate variables:
    
           25┆ process.on('message', async (msg) => {
    
           29┆ const targetUid = msg.uid;
    
    
                This is how taint reaches the sink:
    
           31┆ const archivePath = path.join(__dirname,
               '../../../build/export',                
               `${targetUid}_uploads.zip`);            
    
    
            ⋮┆----------------------------------------
           77┆ const profileUploadPath =          
               path.join(nconf.get('upload_path'),
               `profile/uid-${targetUid}`);       
    
    
          Taint comes from:
    
           25┆ process.on('message', async (msg) => {
    
    
          Taint flows through these intermediate variables:
    
           25┆ process.on('message', async (msg) => {
    
           29┆ const targetUid = msg.uid;
    
    
                This is how taint reaches the sink:
    
           77┆ const profileUploadPath =          
               path.join(nconf.get('upload_path'),
               `profile/uid-${targetUid}`);       
    
                                      
  [36m[22m[24m  src/user/picture.js[0m
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
          231┆ return                             
               path.join(nconf.get('upload_path'),
               `profile/uid-${uid}`, filename);   
    
    
          Taint comes from:
    
          225┆ async function getPicturePath(uid,
               field) {                          
    
    
          Taint flows through these intermediate variables:
    
          225┆ async function getPicturePath(uid,
               field) {                          
    
    
                This is how taint reaches the sink:
    
          231┆ return                             
               path.join(nconf.get('upload_path'),
               `profile/uid-${uid}`, filename);   
    
    
            ⋮┆----------------------------------------
          231┆ return                             
               path.join(nconf.get('upload_path'),
               `profile/uid-${uid}`, filename);   
    
    
          Taint comes from:
    
          225┆ async function getPicturePath(uid,
               field) {                          
    
    
          Taint flows through these intermediate variables:
    
          225┆ async function getPicturePath(uid,
               field) {                          
    
          226┆ const value = await           
               User.getUserField(uid, field);
    
          226┆ const value = await           
               User.getUserField(uid, field);
    
          230┆ const filename = value.split('/').pop();
    
    
                This is how taint reaches the sink:
    
          231┆ return                             
               path.join(nconf.get('upload_path'),
               `profile/uid-${uid}`, filename);   
    
                                      
  [36m[22m[24m  src/user/uploads.js[0m
    ❯❱ [1mjavascript.node-stdlib.cryptography.crypto-weak-[0m
  [1m     algorithm.crypto-weak-algorithm[0m                 
          The use of a weak cryptographic algorithm (e.g., 
          SHA-1 or MD5) has been identified. These         
          algorithms are considered insecure due to        
          vulnerabilities that make them susceptible to    
          collision attacks, allowing attackers to         
          compromise data integrity or security. Replace   
          SHA-1 or MD5 with secure hashing algorithms, such
          as: SHA-256 or higher (e.g., SHA-3).             
          Details: https://sg.run/nJgp1                    
                                                           
           13┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
          Taint comes from:
    
           13┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
                This is how taint reaches the sink:
    
           13┆ const md5 = filename => crypto.createHas
               h('md5').update(filename).digest('hex');
    
    
            ⋮┆----------------------------------------
   
    ❯❱ [1mjavascript.lang.security.audit.path-traversal.path-join-[0m
  [1m     resolve-traversal.path-join-resolve-traversal[0m           
          Detected possible user input going into a    
          `path.join` or `path.resolve` function. This 
          could possibly lead to a path traversal      
          vulnerability,  where the attacker can access
          arbitrary files stored in the file system.   
          Instead, be sure to sanitize or validate user
          input first.                                 
          Details: https://sg.run/OPqk                 
                                                       
           17┆ const _getFullPath = relativePath =>
               path.join(pathPrefix, relativePath);
    
    
          Taint comes from:
    
           17┆ const _getFullPath = relativePath =>
               path.join(pathPrefix, relativePath);
    
    
          Taint flows through these intermediate variables:
    
           17┆ const _getFullPath = relativePath =>
               path.join(pathPrefix, relativePath);
    
    
                This is how taint reaches the sink:
    
           17┆ const _getFullPath = relativePath =>
               path.join(pathPrefix, relativePath);
    
                                   
  [36m[22m[24m  src/webserver.js[0m
     ❱ [1mjavascript.express.security.audit.express-check-csurf-[0m
  [1m     middleware-usage.express-check-csurf-middleware-usage[0m 
          A CSRF middleware was not detected in your      
          express application. Ensure you are either using
          one such as `csurf` or `csrf` (see rule         
          references) and/or you are properly doing CSRF  
          validation in your routes with a token or       
          cookies.                                        
          Details: https://sg.run/BxzR                    
                                                          
           11┆ const app = express();
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-default-name[0m     
          Don’t use the default session cookie name Using  
          the default session cookie name can open your app
          to attacks. The security issue posed is similar  
          to X-Powered-By: a potential attacker can use it 
          to fingerprint the server and target attacks     
          accordingly.                                     
          Details: https://sg.run/1Z5x                     
                                                           
          174┆ app.use(session({
          175┆    store: db.sessionStore,
          176┆    secret: nconf.get('secret'),
          177┆    key: nconf.get('sessionKey'),
          178┆    cookie: setupCookie(),
          179┆    resave: nconf.get('sessionResave') ||
               false,                                  
          180┆    saveUninitialized:                   
               nconf.get('sessionSaveUninitialized') ||
               false,                                  
          181┆ }));
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-no-domain[0m        
          Default session middleware settings: `domain` not
          set. It indicates the domain of the cookie; use  
          it to compare against the domain of the server in
          which the URL is being requested. If they match, 
          then check the path attribute next.              
          Details: https://sg.run/rd41                     
                                                           
          174┆ app.use(session({
          175┆    store: db.sessionStore,
          176┆    secret: nconf.get('secret'),
          177┆    key: nconf.get('sessionKey'),
          178┆    cookie: setupCookie(),
          179┆    resave: nconf.get('sessionResave') ||
               false,                                  
          180┆    saveUninitialized:                   
               nconf.get('sessionSaveUninitialized') ||
               false,                                  
          181┆ }));
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-no-expires[0m       
          Default session middleware settings: `expires`
          not set. Use it to set expiration date for    
          persistent cookies.                           
          Details: https://sg.run/N4eG                  
                                                        
          174┆ app.use(session({
          175┆    store: db.sessionStore,
          176┆    secret: nconf.get('secret'),
          177┆    key: nconf.get('sessionKey'),
          178┆    cookie: setupCookie(),
          179┆    resave: nconf.get('sessionResave') ||
               false,                                  
          180┆    saveUninitialized:                   
               nconf.get('sessionSaveUninitialized') ||
               false,                                  
          181┆ }));
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-no-httponly[0m      
          Default session middleware settings: `httpOnly` 
          not set. It ensures the cookie is sent only over
          HTTP(S), not client JavaScript, helping to      
          protect against cross-site scripting attacks.   
          Details: https://sg.run/ydBO                    
                                                          
          174┆ app.use(session({
          175┆    store: db.sessionStore,
          176┆    secret: nconf.get('secret'),
          177┆    key: nconf.get('sessionKey'),
          178┆    cookie: setupCookie(),
          179┆    resave: nconf.get('sessionResave') ||
               false,                                  
          180┆    saveUninitialized:                   
               nconf.get('sessionSaveUninitialized') ||
               false,                                  
          181┆ }));
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-no-path[0m          
          Default session middleware settings: `path` not 
          set. It indicates the path of the cookie; use it
          to compare against the request path. If this and
          domain match, then send the cookie in the       
          request.                                        
          Details: https://sg.run/b7pd                    
                                                          
          174┆ app.use(session({
          175┆    store: db.sessionStore,
          176┆    secret: nconf.get('secret'),
          177┆    key: nconf.get('sessionKey'),
          178┆    cookie: setupCookie(),
          179┆    resave: nconf.get('sessionResave') ||
               false,                                  
          180┆    saveUninitialized:                   
               nconf.get('sessionSaveUninitialized') ||
               false,                                  
          181┆ }));
   
    ❯❱ [1mjavascript.express.security.audit.express-cookie-[0m
  [1m     settings.express-cookie-session-no-secure[0m        
          Default session middleware settings: `secure` not
          set. It ensures the browser only sends the cookie
          over HTTPS.                                      
          Details: https://sg.run/9oKz                     
                                                           
          174┆ app.use(session({
          175┆    store: db.sessionStore,
          176┆    secret: nconf.get('secret'),
          177┆    key: nconf.get('sessionKey'),
          178┆    cookie: setupCookie(),
          179┆    resave: nconf.get('sessionResave') ||
               false,                                  
          180┆    saveUninitialized:                   
               nconf.get('sessionSaveUninitialized') ||
               false,                                  
          181┆ }));
   
    ❯❱ [1mjavascript.helmet.csp-misconfiguration.csp-misconfiguration[0m
          Untrusted input could be used to tamper with a   
          web page rendering, which can lead to a Cross-   
          site scripting (XSS) vulnerability. XSS          
          vulnerabilities occur when untrusted input       
          executes malicious JavaScript code, leading to   
          issues such as account compromise and sensitive  
          information leakage. To prevent this             
          vulnerability, validate the user input, perform  
          contextual output encoding or sanitize the input.
          Details: https://sg.run/x8AyA                    
                                                           
          220┆ app.use(helmet(options));
    
    
          Taint comes from:
    
          203┆ const options = {
    
          204┆    contentSecurityPolicy: false, //    
               defaults are too restrive and break    
               plugins that load external assets... 🔜
    
          205┆    crossOriginOpenerPolicy: { policy:
               meta.config['cross-origin-opener-    
               policy'] },                          
    
          206┆    crossOriginResourcePolicy: { policy:
               meta.config['cross-origin-resource-    
               policy'] },                            
    
          207┆    referrerPolicy: { policy: 'strict-
               origin-when-cross-origin' },         
    
          208┆    crossOriginEmbedderPolicy:        
               !!meta.config['cross-origin-embedder-
               policy'],                            
    
          209┆ };
    
    
          Taint flows through these intermediate variables:
    
          203┆ const options = {
    
    
                This is how taint reaches the sink:
    
          220┆ app.use(helmet(options));
    
